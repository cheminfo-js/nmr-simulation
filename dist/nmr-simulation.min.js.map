{"version":3,"sources":["webpack:///nmr-simulation/./~/ml-array-utils/src/getEquallySpaced.js","webpack:///nmr-simulation/./src/simulate2D.js","webpack:///nmr-simulation/./src/simulate1D.js","webpack:///nmr-simulation/webpack/universalModuleDefinition","webpack:///nmr-simulation/webpack/bootstrap 1f39b7b8b21dcc6e594f","webpack:///nmr-simulation/./~/ml-matrix/src/matrix.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/base.js","webpack:///nmr-simulation/./~/ml-matrix/src/util.js","webpack:///nmr-simulation/./~/ml-hclust/src/Cluster.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/util.js","webpack:///nmr-simulation/./~/ml-matrix/src/index.js","webpack:///nmr-simulation/./~/new-array/index.js","webpack:///nmr-simulation/./~/binary-search/index.js","webpack:///nmr-simulation/./~/ml-distance-euclidean/euclidean.js","webpack:///nmr-simulation/./~/ml-hclust/src/ClusterLeaf.js","webpack:///nmr-simulation/./~/ml-matrix/src/abstractMatrix.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/lu.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/svd.js","webpack:///nmr-simulation/./~/ml-sparse-matrix/src/SparseMatrix.js","webpack:///nmr-simulation/./~/ml-stat/array.js","webpack:///nmr-simulation/./~/ml-stat/index.js","webpack:///nmr-simulation/./~/num-sort/index.js","webpack:///nmr-simulation/./src/SpinSystem.js","webpack:///nmr-simulation/./src/pauli.js","webpack:///nmr-simulation/./~/heap/index.js","webpack:///nmr-simulation/./~/heap/lib/heap.js","webpack:///nmr-simulation/./~/ml-array-utils/src/ArrayUtils.js","webpack:///nmr-simulation/./~/ml-array-utils/src/index.js","webpack:///nmr-simulation/./~/ml-array-utils/src/snv.js","webpack:///nmr-simulation/./~/ml-distance-matrix/src/index.js","webpack:///nmr-simulation/./~/ml-hash-table/src/HashTable.js","webpack:///nmr-simulation/./~/ml-hash-table/src/primeFinder.js","webpack:///nmr-simulation/./~/ml-hclust/src/agnes.js","webpack:///nmr-simulation/./~/ml-hclust/src/diana.js","webpack:///nmr-simulation/./~/ml-hclust/src/index.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/cholesky.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/evd.js","webpack:///nmr-simulation/./~/ml-matrix/src/dc/qr.js","webpack:///nmr-simulation/./~/ml-matrix/src/decompositions.js","webpack:///nmr-simulation/./~/ml-matrix/src/symbol-species.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/column.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/flipColumn.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/flipRow.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/row.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/selection.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/sub.js","webpack:///nmr-simulation/./~/ml-matrix/src/views/transpose.js","webpack:///nmr-simulation/./~/ml-simple-clustering/src/index.js","webpack:///nmr-simulation/./~/ml-stat/matrix.js","webpack:///nmr-simulation/./~/number-is-nan/index.js","webpack:///nmr-simulation/./~/process/browser.js","webpack:///nmr-simulation/./~/util/~/inherits/inherits_browser.js","webpack:///nmr-simulation/./~/util/support/isBufferBrowser.js","webpack:///nmr-simulation/./~/util/util.js","webpack:///nmr-simulation/(webpack)/buildin/global.js","webpack:///nmr-simulation/./src/index.js"],"names":[],"mappings":"4BAmLA,qBC5G4B,KAAK,eCpCJ,KAAK,8LCnClC,cACA,2BACA,uCACA,sCACA,cACA,GACA,+CAEA,oBACA,GAAC,mBACD,kBCTA,cAMA,MACA,eAGA,mBACA,GACA,EACA,KAIA,mDAGA,KAGA,OACA,OAIA,IAzBA,iBA4BA,MAGA,iBAA2C,OAAc,EAGzD,qBACA,OACA,8BACA,CACA,gBACA,kBAGA,GAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,OAAe,EAChD,mBACA,GACA,CAGA,mBAAsD,+CAA+D,EAGrH,MAGA,+BChEA,aAEA,MACA,QACA,WAEA,wBACA,iBACA,IACA,4BACA,gCAEA,iBACA,YACS,gCACT,cACA,wBACA,UAA2B,IAAW,EACtC,kBAGA,4BAES,iEACT,SACA,SACA,cACA,2BACA,0BAEA,+DACA,KAAuB,IAAW,MAClC,kBACA,uBAEA,qDACA,GACA,CACA,0BAEA,yEACA,eACA,EACA,IAEA,WACA,mBACA,EACA,IAEA,SACA,gBACA,EAMA,QACA,+DACA,WAAyB,SAAiB,KAC1C,cAAgC,SAAuB,QACvD,yBAGA,UACA,EAOA,aACA,yBACA,GACA,mCAEA,+DACA,cACA,EACA,IAQA,YACA,OACA,gBACA,SAEA,2BACA,8BACA,sBACA,cACA,EACA,IAOA,gBACA,4BACA,GACA,sCAEA,uDAAuB,SAAe,KACtC,qBAEA,wBACA,EACA,IAQA,eACA,CACA,0BACA,SAEA,iCACA,iCACA,aAAuB,SAAe,KACtC,yBAEA,yBACA,EACA,IACA,EAEA,WACA,oCC5IA,aAEA,QACA,WAEA,mBACA,mBACA,CACA,oBACA,YACA,eACA,CAEA,6BACA,UACA,MACA,EAEA,6BClBA,aAEA,QAQA,GACA,+BACA,uBACA,YACA,uBAEA,yBAQA,EACA,kCACA,6BACA,YACA,uBAEA,4BASA,EACA,8BACA,MACA,gBAEA,0BACA,6BAEA,+DACA,EASA,EACA,iCACA,MACA,gBAEA,0BACA,0BAEA,4DACA,IAEA,8BACA,mBACA,kBAEA,IAEA,iBACA,kBACA,OAEA,SACA,uBAGA,mDACA,uCAEA,iFACA,oCAEA,IACA,KACA,SAEA,IAEA,gCACA,6CACA,8EACA,OACA,kBACA,4BACA,mGACA,6BAEA,uCAEA,wBACA,qBACA,KAAmB,MAAgB,OACnC,WAEA,QACA,IAEA,sBACA,iCACA,KAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,iCAGA,UACA,IAEA,yBACA,8BACA,WAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,iCAGA,UACA,IAEA,oBACA,WACA,IAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,eAGA,SACA,qBC7IA,aAIA,YACA,MACA,2BACA,OACA,QAMA,CAZA,cAaA,2BACA,6BACA,gCACA,mBACA,yBACA,sBACA,mBACA,GACA,KACA,gBACA,aACA,gBAEA,gBAGA,gBACA,EAMA,EACA,6BACA,mDAEA,0EACA,qBACA,QAEA,cAEA,kBACA,SACA,SACA,sBAEA,qCACA,GAEA,UACA,uBACA,0BAEA,SACA,CAMA,EACA,gCACA,gBACA,MACA,KACA,qCAAkD,EAAQ,KAC1D,oBAGA,EACA,QACA,IAEA,2BChFA,aAEA,0BACA,IACA,+BACA,QACA,4BAEA,IACA,MAIA,OAHA,4BAEA,GAMA,EACA,+BACA,iBACA,KAAmB,IAAU,EAC7B,eAEA,SACA,IAEA,kCACA,iBACA,KAAmB,IAAU,MAC7B,YACA,aAAuB,IAAa,EACpC,YAEA,CACA,OACA,qBCpCA,aAEA,sBACA,yDCHA,UAEA,aACA,MACA,kBACA,KAAiB,IAAO,EACxB,SAEA,QACA,iBCTA,6BACA,OAEA,KACA,aAGA,aACA,YACA,4BAGA,0BACA,sBAGA,aACA,YACA,4BAGA,+BAGA,gBACA,iBAGA,GACA,QAGA,UACA,QAIA,aAIA,UACA,gBC1CA,aAEA,eACA,WACA,IAAmB,MAAc,OACjC,2BAEA,UACA,GAEA,eACA,sBACA,IAEA,YACA,6BCfA,aAKA,aACA,QACA,iBACA,gBACA,OACA,YARA,UACA,WASA,gBAEA,0DCdA,aAgBA,gEAiiDA,eACA,oBACA,6BAEA,oCAEA,6BACA,UACA,CAMA,mCAmNA,aACA,2CAEA,UACA,EAEA,gCA9vDA,sCACA,6BACA,OACA,KASA,0BACA,MACA,MACA,4BAEA,oEACA,KAA6B,IAAe,EAC5C,cAAoC,IAAqB,EACzD,oBAGA,UACA,EAOA,oBACA,wBACA,UAA2B,MAAoB,OAC/C,gBAEA,UACA,EAOA,uBACA,6BACA,KAA2B,MAAoB,OAC/C,gBAEA,UACA,EAQA,kBACA,mBACA,EAQA,kBACA,6BACA,EAQA,iBACA,6BACA,EASA,mBACA,qBACA,+BACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,cAGA,WACA,EAUA,wBACA,cACA,2BACA,+BACA,KAA2B,IAAU,EACrC,gBAA+B,IAAa,EAC5C,qBACA,aAGA,SACA,EASA,kBACA,gBACA,kBACA,wBACA,kBACA,KAA2B,IAAS,EACpC,cAEA,SACA,EASA,mBACA,SACA,sBACA,kBACA,0BACA,kBACA,KAA2B,IAAS,EACpC,gBAEA,UACA,EAQA,gBACA,oBACA,sBACA,eACA,SACA,qBACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,0CAGA,WACA,EAQA,gBACA,oBACA,sBACA,eACA,SACA,qBACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,0CAGA,WACA,EAOA,sBACA,sCACA,EAOA,mBACA,iBACA,kBAKA,WACA,uBACA,OAOA,SACA,IACA,yCAEA,8CACA,YACA,UAA2B,IAAQ,EACnC,cAA+B,IAAQ,EACvC,kBAGA,SACA,KAMA,YACA,sBACA,QAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,mCAGA,SACA,EAMA,YACA,sBACA,QAA2B,SAAe,SAC1C,iBACA,mBAA+B,SAAkB,QACjD,uBAEA,EACA,OACA,EAKA,cACA,OACA,cAKA,iBACA,OACA,iBAKA,WACA,uBACA,gBAKA,WACA,yBACA,OAKA,cACA,oBACA,WAA+B,SAAe,KAC9C,cAAmC,KAAQ,EAC3C,kCACA,GAIA,SACA,QACA,CACA,QAUA,MACA,iBACA,8BASA,MACA,iBACA,8BAYA,YACA,MACA,OACA,0EACA,KAA2B,IAAY,EACvC,cAA+B,IAAY,EAC3C,iDAGA,SACA,EAOA,QACA,WAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iBAGA,SACA,KAMA,MACA,mBACA,EAOA,UACA,yBACA,wBACA,WAA2B,SAAkB,QAC7C,oBAEA,SACA,EAOA,gBACA,+CACA,GAQA,YACA,yBACA,8BACA,aAA2B,SAAkB,QAC7C,mBAEA,UACA,KAQA,cACA,yBACA,2BACA,eAA2B,SAAkB,QAC7C,iBACA,2BACA,iBAEA,SACA,KAOA,aACA,4BACA,wBACA,QAA2B,SAAe,KAC1C,oBAEA,SACA,EAOA,mBACA,qDACA,GAQA,eACA,4BACA,iCACA,aAA2B,SAAe,KAC1C,mBAEA,UACA,KAQA,iBACA,4BACA,8BACA,eAA2B,SAAe,KAC1C,iBACA,2BACA,iBAEA,SACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAQA,YACA,yBACA,aAA2B,SAAkB,QAC7C,+BAEA,SACA,KAQA,eACA,4BACA,aAA2B,SAAe,KAC1C,+BAEA,SACA,KAMA,MACA,sBACA,KAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBAIA,UACA,EAMA,WACA,sBACA,GACA,UAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBACA,QACA,OAIA,SACA,EAMA,MACA,sBACA,KAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBAIA,UACA,EAMA,WACA,sBACA,GACA,UAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBACA,QACA,OAIA,SACA,EAOA,UACA,yBACA,wBACA,KAA2B,SAAkB,QAC7C,kBACA,iBAGA,UACA,EAOA,eACA,yBACA,wBACA,QACA,KAA2B,SAAkB,QAC7C,kBACA,iBACA,QAGA,SACA,EAOA,UACA,yBACA,wBACA,KAA2B,SAAkB,QAC7C,kBACA,iBAGA,UACA,EAOA,eACA,yBACA,wBACA,QACA,KAA2B,SAAkB,QAC7C,kBACA,iBACA,QAGA,SACA,EAOA,aACA,4BACA,wBACA,KAA2B,SAAe,KAC1C,kBACA,iBAGA,UACA,EAOA,kBACA,4BACA,wBACA,QACA,KAA2B,SAAe,KAC1C,kBACA,iBACA,QAGA,SACA,EAOA,aACA,4BACA,wBACA,KAA2B,SAAe,KAC1C,kBACA,iBAGA,UACA,EAOA,kBACA,4BACA,wBACA,QACA,KAA2B,SAAe,KAC1C,kBACA,iBACA,QAGA,SACA,EAMA,OACA,mCACA,iBACA,KAA2B,IAAS,EACpC,oBAEA,SACA,EAQA,OACA,OAEA,QADA,gBAEA,MACA,8BAEA,kBAEA,KAMA,OACA,wBACA,IAMA,OACA,WACA,IAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBAGA,SACA,EAMA,gBACA,WACA,IAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,gBAGA,SACA,KAOA,OACA,0BACA,wBACA,4BACA,4BAEA,+CACA,IAA2B,MAAoB,OAC/C,cAEA,SACA,EAOA,QACA,gCACA,oBAEA,mBAGA,oGACA,YACA,YAEA,iDAEA,WACA,KAA2B,IAAO,MAClC,WAA+B,IAAO,EACtC,iBAGA,eAA+B,IAAO,MACtC,OACA,IAA+B,IAAO,EACtC,uBAGA,aACA,EACA,CACA,OACA,EAEA,eACA,8CACA,sBACA,aACA,gBACA,aACA,gBACA,aACA,gBACA,aAGA,cACA,WACA,SACA,UACA,WACA,iBAUA,MALA,WADA,YAOA,IALA,WAMA,IALA,WAMA,MAJA,WARA,IAaA,CAEA,eACA,8CAEA,sBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBAEA,aACA,aACA,aACA,aACA,cACA,cACA,cACA,cACA,cAEA,gBAEA,qBAEA,iBACA,QACA,mBACA,iBACA,iBACA,sBAGA,iBACA,SACA,iBACA,uBACA,iBACA,kBACA,mBAiBA,KAVA,KANA,WAiBA,kBAnCA,kBAyBA,YAWA,2BA3BA,SAiBA,YAWA,wBAnCA,gBAyBA,YAWA,WAVA,KATA,YAoBA,WAVA,KATA,WAoBA,8BA9BA,UAoBA,YAWA,WAVA,KAVA,WAqBA,WATA,KAVA,IAoBA,CAOA,gBACA,kBAaA,SACA,SACA,sBACA,QAEA,yBACA,iCACA,GAEA,EAOA,oBAQA,YACA,qBAIA,WACA,oBACA,eACiB,IACjB,kBACA,aACiB,IACjB,mBACA,aAGA,0BACA,yBAEA,6BACA,6BAEA,qCACA,qCAEA,kCACA,kCAEA,0CACA,0CAGA,8CACA,gCACA,gCACA,gCACA,gCACA,+CACA,+CAGA,qBACA,WACA,WACA,yBACA,qBACA,qBACA,WACA,WAGA,uCACA,wCACA,iCACA,8BACA,0CACA,gCACA,EACA,YA9FA,YACA,SACA,YACA,SACA,YAEA,+BAA4C,CAAG,MAAK,CAAG,QAAO,CAAG,MAAK,CAKtE,sDAkBA,gBACA,kBACA,WAGA,WA6DA,EAQA,eACA,mBACA,iBACA,KACA,uBAEA,6FACA,WAA2B,SAAe,KAC1C,uCAA+D,MAC/D,mBAEA,SACA,EAWA,kBACA,mBACA,iBACA,KACA,uBAEA,6FACA,WAA2B,SAAkB,QAC7C,yCACA,KACA,MAEA,kBAEA,SACA,EASA,oBACA,gCAEA,kBACA,YACA,YACA,SAEA,qDACA,KAA2B,IAAO,EAClC,cAA+B,IAAO,EACtC,cAAmC,IAAO,EAC1C,cAAuC,IAAO,EAC9C,0CAKA,SACA,EAMA,YACA,kEACA,QAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,yBAGA,UACA,EAOA,YACA,gBACA,0BAA2B,SAAe,KAC1C,sCAEA,UACA,KAOA,eACA,gBACA,0BAA2B,SAAkB,QAC7C,4CAEA,UACA,KAUA,mBACA,4BACA,4DACA,KAAkC,KAAa,EAC/C,cAAyC,KAAgB,EACzD,2BAGA,SACA,EASA,oBACA,mBACA,+BACA,2CACA,6BAGA,qFACA,KAA2B,MAAoB,OAC/C,cAAyC,KAAgB,MACzD,uBACA,uDAEA,8BACA,GAEA,OACA,EASA,uBACA,mBACA,4BACA,wCACA,0BAGA,gFACA,UAA2B,MAAoB,OAC/C,cAAsC,KAAa,MACnD,uBACA,6DAEA,6BACA,IAEA,OACA,EASA,oBACA,gCACA,kBACA,gBACA,6BACA,aAA2B,MAAiB,KAC5C,cAA+B,MAAoB,QACnD,2BAGA,SACA,KAQA,eACA,sCACA,qDACA,UAA2B,UAAwB,WACnD,SACA,eAA+B,aAA2B,OAC1D,eACA,sBAEA,EACA,OACA,EAMA,QACA,mCACA,WACA,IAA2B,IAAS,EACpC,kBAEA,SACA,EAUA,gBACA,gCACA,KAOA,WACA,gCACA,0BACA,EAOA,cACA,mCACA,6BACA,EAMA,cACA,8BACA,KAMA,iBACA,iCACA,KAUA,uBACA,qCACA,EAWA,mBACA,uCACA,EASA,MACA,oBACA,WACA,KAEA,qCACA,gBACA,gBACA,gBAEA,SACiB,sBAEjB,SACA,gBACA,kCACA,kCACA,wCACA,gBACA,gBAEA,2BACA,KAEA,kCAGA,WACA,aAEA,0DAOA,iBACA,uBACA,6CAEA,uBACA,wBACA,yBAEA,WAA2B,MAAc,OACzC,wBACA,MAOA,oDACA,mBACA,iBAGA,yBAQA,8BAgBA,4BACA,gDACA,4BACA,6CACA,oDACA,+DAMA,wBAOA;;;;;wBAWA;;;;;;;;;wBAaA;;;;;;;;;;;iBAOA;;;;;gBAWA;;;;;;;;;eAOA;;;;;wBAWA;;;;;;;;;uBAQA;;;;;gCAUA;;;;;;;;;gCAaA;;;;;;;;;;;0BAOA;;;;;yBAEA,qBAgBA,oPAEA,gCACA,0DAAoE,6BACpE,kEAA2E,iCAC3E,kEAA2E,iCAC3E,yDAAkE,cAClE,YAAmB,aAAqB,OACxC,kCACA,4CACA,6CACA,+BAEA,QAEA,IAIA,uBAIA,+NACA,yBACA,GAEA,EAhtDA,2BAitDA,0DAAoE,6BACpE,yDAAkE,YAClE,YAAmB,WAAmB,OACtC,gCACA,8BAEA,UAEA,IAIA,iFACA,UACA,aAAmB,kBAAsB,GACzC,kBAA4B,CAE5B,2BACA,yEACA,oBACA,wBACA,QAEA,2EAAsF,2BACtF,cAAuB,kBAA0B,OACjD,uCACA,6CAEA,kBAAS,KACT,aACA,oBACA,QACA,0BAEA,qEACA,iFACA,iFACA,yEACA,gBAAuB,kBAA0B,OACjD,uCACA,sDACA,sDACA,wCAEA,aACA,CAEA,OAQA,QAvxDA,8BAEA,wCACA,wCACA,mCACA,6BACA,2CACA,sCACA,sCACA,4CACA,yCACA,0CACA,kECdA,aAKA,aACA,qBACA,iBAGA,0BAEA,qBAMA,SAEA,OAPA,YACA,SACA,gBACA,KACA,QAGe,IAAU,EACzB,SAGA,eAEA,KAAe,IAAa,MAE5B,OAAmB,IAAU,EAC7B,eAGA,SAAmB,IAAU,MAC7B,UACA,iBACA,MACA,IAAuB,IAAU,GACjC,iBAEA,gBACA,EAEA,OACA,MAAuB,IAAU,EACjC,gCACA,QAIA,YACA,OAAuB,IAAa,EACpC,YACA,gBACA,WAGA,QACA,UACA,QAEA,MACA,CAEA,SACA,oBAA2B,IAAU,EACrC,kBAGA,EAEA,SACA,mBACA,iBACA,EAvEA,QAEA,GAuEA,YACA,sBACA,gBACA,OACA,UAAuB,IAAS,EAChC,OACA,YAGA,SACA,QACA,mBACA,YACA,SACA,2BAEA,sDACA,UAAuB,IAAS,EAChC,YAEA,SACA,EACA,6BACA,gBACA,OACA,SACA,yBACA,KAAuB,IAAU,EACjC,cAA2B,IAAa,EACxC,cACA,OACiB,OACjB,EAEA,EAIA,QACA,EACA,6BACA,gBACA,OACA,SACA,yBACA,KAAuB,IAAU,EACjC,cAA2B,IAAa,EACxC,eACA,OAEA,GAIA,QACA,EACA,8BACA,yBACA,OACA,mBACA,wBAEA,cACA,OAEA,cACA,qBAEA,qCACA,6BAGA,iCACA,8CACA,OACA,YAEA,QAAmB,IAAa,EAChC,YAA2B,IAAa,EACxC,UAA2B,IAAW,EACtC,0BAIA,WAA6B,EAAQ,SACrC,OAAuB,IAAW,EAClC,kBAEA,SAAuB,IAAO,EAC9B,UAA2B,IAAW,EACtC,0BAGA,EACA,OACA,EACA,GAEA,6BC7KA,aAQA,eACA,qBACA,mBAEA,0BAEA,KAEA,cACA,SACA,qBAEA,QACA,yCACA,2CACA,SAIA,cAFA,cACA,aAEA,QAiBA,iBAhBA,QAEA,qBACS,8FACT,MACA,iBACA,UACA,QACA,aACA,IACA,IACA,EAEA,mCAaA,8BAEA,yBAXA,aACA,YACA,YACA,YAEA,mBACA,8BAEA,4BAGyC,OAAS,QAClD,UACA,YACA,KAAuB,MAAO,EAC9B,4BAEA,mBACA,KACA,0BAEA,QAA2B,MAAO,EAClC,oBAEA,gBACA,CACA,YACA,GAEA,WAAuB,KAAO,OAC9B,sBACA,QACA,KAA2B,MAAO,EAClC,2BAEA,sBACA,OAA2B,MAAO,EAClC,2BAEA,GACA,eACA,GAEA,UACA,UAAuB,MAAO,EAC9B,uBAIA,aACA,YACA,QAA2B,KAAO,EAClC,wBAEA,mBACA,KACA,yBAEA,WAA+B,KAAO,EACtC,gBAEA,cACA,CACA,eACA,uBACA,WAA+B,KAAO,EACtC,YAEA,YAA+B,KAAO,EACtC,eAAmC,KAAO,EAC1C,2BAGA,cAA+B,KAAO,EACtC,0BACA,SAAmC,KAAO,EAC1C,uBAGA,GACA,IACA,YAA+B,KAAO,EACtC,mBAGA,GACA,CAEA,oBACA,MACA,kBAEA,OACA,cAEA,QACA,sBAEA,aAEA,IACA,QAAqB,MAAQ,OAC7B,QAAuB,KAAO,EAC9B,gBAEA,aACA,CACA,WAAyB,EAAQ,MACjC,mBACA,WAA+B,KAAQ,OACvC,QACA,KAA+B,MAAO,EACtC,2BAEA,sBACA,OAA+B,MAAO,EACtC,2BAEA,GACA,QAA2B,MAAO,EAClC,wBAEA,4BACA,OAA2B,QAAW,EACtC,gBAEA,CAAa,KACb,QAA2B,KAAO,EAClC,gBAEA,aACA,CAEA,CAEA,IACA,WAAuB,EAAQ,WAC/B,WACA,qBAA+B,KAAO,OACtC,QACA,QAAmC,KAAO,EAC1C,2BAEA,wBACA,UAAmC,KAAO,EAC1C,2BAEA,GAEA,QAAuB,KAAO,EAC9B,gBAEA,aACA,CAGA,eACA,KACA,EACA,+BACA,WAAuB,GAAS,QAIhC,OAHA,mEAIA,QACA,EACA,KAEA,YACA,KACS,MACT,WAA4B,MAAS,SAIrC,GAHA,mDAIA,8CACA,QACA,EACA,KAEA,MACA,MACa,UACb,KAEA,MACA,KAEA,GAEA,QAEA,KACA,WACA,cACA,YACA,QAA+B,MAAQ,GACvC,oBACA,cACA,SACA,UACA,QACA,kBACA,qBAEA,IACA,SAAmC,KAAO,EAC1C,mCACA,4CACA,cAIA,GACA,KACA,QACA,cACA,YACA,KAA2B,MAAO,GAClC,oBACA,cACA,SACA,UACA,aACA,iBACA,IACA,SAAmC,KAAO,EAC1C,mCACA,4CACA,cAIA,GACA,KACA,QACA,qIACA,kBACA,eACA,eACA,aACA,aACA,8BACA,eACA,OACA,WACA,6BACA,IACA,WAEA,cAEA,wBACA,SACA,MAA2B,SAAW,OACtC,YACA,UACA,SACA,QACA,cAEA,uBACA,2BACA,gBACA,qBACA,GACA,SAAmC,KAAO,EAC1C,mCACA,4CACA,cAGA,cACA,UACA,SACA,UACA,yBACA,gCACA,eACA,qBACA,WACA,SAAmC,KAAO,EAC1C,mCACA,4CACA,cAGA,EACA,UAEA,QACA,KACA,QACA,IACA,oCACA,EACA,UAAmC,MAAS,GAC5C,wBAIA,YACA,oBAGA,eACA,iBACA,YACA,WACA,SAAmC,KAAO,EAC1C,kBACA,uBACA,eAGA,cACA,SAAmC,KAAO,EAC1C,kBACA,uBACA,eAGA,GAEA,QACA,EACA,KACA,KAGA,EAEA,OACA,QACA,MACA,MACA,EAEA,QACA,SACA,SACA,UACA,UACA,GArYA,QACA,OACA,OACA,eAEA,iBAkYA,YACA,gBACA,iDACA,EACA,aACA,eACA,EACA,YAEA,0CACA,2BACA,SACA,UAAsC,SAAQ,EAC9C,SACA,GAGA,UACA,EACA,gBACA,aACA,CAEA,iBACA,+DACA,EACA,2BACA,+BACA,8BAEA,SACA,CACA,4BACA,+BACA,8BAEA,SACA,CACA,sBACA,2BACA,EACA,mBAEA,IAMA,UAJA,mBACA,0BACA,SAEmB,IAAW,EAC9B,iCACA,EAEA,WAIA,cACA,UAEA,gCACA,SACA,UACA,4BACA,UAEA,SAAmB,IAAW,GAC9B,WAAuB,KAAW,QAClC,QACA,KAA2B,KAAW,EACtC,yBAEA,cACA,EAGA,WACA,KAjCA,EAkCA,8BACA,iCACA,GACA,oBACA,YACA,SACA,cACA,cACA,+BACA,UAEA,QAAmB,IAAW,EAC9B,UAAuB,IAAW,EAClC,gCACA,iBAEA,GAKA,cAEA,QACA,gBACA,yBACA,OAEA,SAAmB,IAAW,EAC9B,UAAuB,IAAW,OAClC,QACA,KAA2B,KAAW,GACtC,wBAEA,aACA,EAGA,OACA,GACA,GAEA,0DCnOA,kCACA,aACA,2CAEA,UACA,GAnSA,wCAEA,kBACA,iBAA2C,KAC3C,8BACA,SACA,EAEA,6DADA,UAGA,qBACA,SACA,MACA,SACA,aACA,yCACA,qBAA2B,IAAU,EACrC,gBAA+B,IAAa,EAC5C,WACA,kDACA,GACA,oCAIA,GACA,wCAEA,UAEA,eACA,WACA,eACA,gBACA,oBACA,CAEA,oBACA,oBACA,2BAAwD,gBACxD,cAAuB,IAAS,EAChC,cAEA,SACA,EAEA,QACA,yBACA,KAEA,YACA,oBACA,gBAAuB,SAAe,SACtC,iBACA,mBAA2B,SAAkB,QAC7C,uBAEA,EACA,OACA,EAEA,WACA,yBACA,OAEA,cACA,qBAEA,YACA,0CACA,wBACA,EAIA,GADA,QAEA,GACA,CAEA,kBACA,sBACA,IAEA,WACA,uBACA,OAEA,SACA,yCACA,EAEA,WACA,uDACA,GACA,0CAEA,sCAEA,GACA,IAEA,QACA,kBACA,mBAEA,kGACA,SAEA,6BACA,uCACA,kCACA,YACA,0BAEA,GACA,CACA,GACA,CACA,GACA,CAEA,oBACA,cACA,YACA,YACA,SAEA,mCACA,oCAEA,kDACA,kCACA,4BACA,GACA,CACA,GACA,CACA,GACA,CAEA,kBACA,yCACA,SACA,0BACA,oBACA,SACA,wDACA,OACA,IACA,2BAEA,0BAIA,OACA,iBACA,sBACA,IAEA,cACA,cACA,oBACA,WACA,WACA,SACA,sCACA,aACA,OACA,OACA,EACA,IACA,CACA,IAAgB,iBAChB,SAEA,gBACA,wBACA,2BACA,+BAEA,IACA,IACA,EAEA,sCAEA,uCACA,6EAEA,eAIA,iCASA;;;;;CAPA,uBAcA;;;;;wBAUA;;;;;;;;iBAOA;;;;;gBAOA;;;;;eAOA;;;;;EAcA,oPAEA,mBACA,qBAAmB,aAAqB,OACxC,mFAA0F,6BAC1F,+FAAsG,iCACtG,+FAAsG,iCAEtG,0EAA+E,cAE/E,MAEA,GAEA,uBAMA,+NACA,yBACA,GAAC,GAED,iBACA,mBAAmB,WAAmB,OACtC,+EAAsF,6BACtF,sEAA2E,YAE3E,qBC5RA,aAEA,eACA,UACA,CAMA,CACA,iBACA,WACA,IAAmB,MAAmB,OACtC,SAEA,SACA,EAMA,EACA,iBACA,aACA,OACA,SAAmB,IAAO,EAC1B,iBAEA,UACA,EAMA,EACA,iBACA,aACA,OACA,SAAmB,IAAO,EAC1B,iBAEA,UACA,EAMA,EACA,oBACA,aACA,OACA,OACA,SAAmB,IAAO,EAC1B,iBACA,iBAEA,UACA,KACA,MAEA,EAMA,EACA,4BACA,WACA,MACA,SAAmB,IAAO,EAC1B,SAEA,YACA,CAIA,EACA,SAMA,eACA,2BACA,WACA,MACA,SAAmB,IAAO,EAC1B,SAEA,uBACA,EAQA,EACA,qBACA,WACA,MACA,SAAmB,IAAO,EAC1B,kBAEA,aACA,CAOA,EACA,yBACA,WACA,IACA,MACA,SAAmB,IAAO,EAC1B,cACA,QAEA,YACA,CAQA,EACA,+BACA,cACA,MACA,wBAEA,gBACA,sBACA,KACA,IAAmB,MAAa,EAChC,SAEA,iBACA,EAMA,EACA,0BACA,WACA,MACA,SAAmB,IAAO,MAC1B,IACA,kDAEA,kBACA,EACA,UACA,CAMA,EACA,gCACA,WACA,IACA,MACA,SAAmB,IAAO,EAC1B,cACA,QAEA,MACA,yBAEA,sCACA,CAOA,EACA,sBACA,cACA,MACA,wBAEA,YACA,sBACA,SACA,QAEA,oBAEA,EAOA,EACA,wBACA,cACA,yBACA,KACA,MAEA,SAAmB,IAAO,EAC1B,WACA,OAGA,QACA,QAEA,KAEA,CAOA,EACA,iCACA,+BACA,KAEA,2BACA,2CACA,OAOA,EACA,gCACA,WACA,eACA,QAAe,IAAY,EAC3B,SAEA,MACA,cACA,SAAe,IAAY,EAC3B,uBACA,iBACA,KACA,kBAEA,6BAGA,OACA,MACA,QAEA,IAEA,yBACA,yBACA,MACA,wBAGA,mBACA,mBACA,cACA,yBAEA,UAAY,aACZ,IAEA,uCACA,qCACA,KAEA,8BACA,yBACA,gBACA,UACA,SAAmB,IAAO,MAC1B,SACA,gBAEA,mBAEA,KACA,WAEA,IACA,MACA,UACA,GAEA,kBACA,IAGA,OAFA,eACA,SACe,IAAO,EACtB,SAEA,cACA,KAEA,QAAe,IAAO,MACtB,mBACA,IACA,OAEA,aACA,QACA,EAEA,IAEA,WACA,QAAe,IAAW,EAC1B,SACA,QACA,KAIA,YACA,IAEA,4BACA,yBACA,mBACA,YAEA,mBACA,YAEA,0DACA,SAAmB,IAAO,MAC1B,YACA,SACA,OACA,CAEA,OACA,QAEA,KACA,GAEA,wBACA,yBACA,yBAEA,eACA,SAAmB,IAAO,EAC1B,WACA,OACA,SAEA,UACA,MAEA,kBACA,UACA,uBACA,iBACA,GACA,EACA,OAEA,KAEA,wBACA,yBACA,yBACA,oBAEA,IAAmB,IAAO,EAC1B,WACA,OACA,WAEA,UACA,MAEA,OACA,aACA,YAEA,mCADA,OAIA,yBADA,IAEA,gBAEA,GAEA,uBACA,2BACA,mBACA,SAAmB,IAAO,EAC1B,0BACA,UACA,GAEA,4BACA,iBACA,SAAmB,IAAO,EAC1B,cACA,SACA,IAEA,yCACA,uCACA,KAEA,gCACA,4BACA,WACA,aAEA,IAAmB,IAAO,MAC1B,YACA,MAEA,WACA,MACA,OACA,CAEA,kBACA,KAEA,sBACA,yBAEA,YACA,EACA,gBAEA,4BACA,SAAmB,IAAO,EAC1B,UACA,GAEA,6BACA,+CACA,4BACA,kBACA,mBACA,KAAmB,IAAO,EAC1B,cACA,QACA,IAEA,2BACA,SAC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UACA,GACA,UACA,IACA,2BAAkD,wBAAsC,iBACxF,kBAEA,WACA,GAEA,0BACA,WACA,OACA,cAEA,SACA,WACA,aACA,QACA,gBACA,QACA,MACA,GACA,QACA,CACA,KACA,eACA,EAEA,uBACA,iBACA,OACA,cAEA,SACA,UACA,SACA,YACA,KACA,UACA,WACA,0BAEA,cACA,OACA,WAEA,gBACA,eACA,GAEA,cACA,gBAiBA,mBACA,UACA,QAEA,gBAnBA,SAEA,aAEA,aAEA,aAEA,gBAEA,eAEA,gBAEA,iCAMA,6BACA,IAEA,6BACA,0BACA,IAEA,8BACA,mBACA,EAEA,oCACA,QACA,0BAEA,mCACA,6BACA,IAEA,mCACA,6BACA,IAEA,iCACA,0BACA,IAEA,sCACA,8BACA,IAEA,+BACA,aACA,QAEA,+BACA,OACA,sBAEA,8BACA,mBACA,MAEA,+BACA,IACA,iBACA,8BACA,GACA,EAEA,iCACA,yBACA,EAEA,mCAEA,mCAEA,qCAEA,mCAEA,wCAEA,MAEA,EAEA,mBAEA,iFAMA,GAAG,iBACH,OACA,EAEA,EAAC,+BCtXD,aAoGA,aACA,sBACA,UAAkB,MAAyB,OAC3C,iBAGA,cAAe,MAAmB,OAClC,cAAsB,SAAsB,OAC5C,iBAIA,SACA,EASA,CAxHA,cAUA,MA0MA,UACA,CACA,mBA3MA,aACA,IACA,mCAGA,0FACA,UAEA,MACA,KAAkB,OAAkB,aACpC,UACA,cAAsB,KAAgB,EACtC,iBAGA,UACA,GACA,IAEA,OACA,EAcA,EA0KA,wBAzKA,aACA,IACA,mCAGA,oFACA,cACA,KAAmB,OAA6B,OAChD,iBAGA,UAAc,OAAkB,WAChC,gBAAsB,KAAgB,EACtC,sBACA,kBAIA,UACA,EAWA,EA4IA,wBA3IA,WACA,+BACA,UACA,IAAkB,SAA2B,OAC7C,eAAsB,OAAwB,OAC9C,gBACA,GAIA,UACA,EASA,sBAwHA,EACA,mBAjGA,WACA,+BACA,UACA,IAAkB,MAAmB,OACrC,eAAsB,UAAsB,OAC5C,eACA,IAIA,UACA,EAUA,sBA6EA,EACA,gBA7EA,aACA,OACA,cACA,UACA,IAEA,MACA,IAGA,mCACA,WAEA,OAAmB,KAAgB,QACnC,IACA,aAAuB,OAA2B,OAClD,oBAEA,WACA,EAEA,OACA,GAQA,EAgDA,MA/CA,aACA,IACA,KACA,QAGA,UAEA,kBACA,SACA,OACA,uBACA,wCACA,wBACA,UAAwB,YACxB,6BAIA,yBACA,QACA,QAAwB,YACxB,iBAKA,YACA,qCACA,SACA,QAAwB,YACxB,iBAIA,SACA,oB1B5LA,aAqDA,qBACA,wBA8BA,mBACA,GAEA,SA/BA,kBACA,MAGA,IADA,WAGA,aACA,+BAGA,MACA,SAEA,YACA,aACA,UACA,MAEA,KACA,KACA,KACA,KACA,KAEA,KACA,KAEA,cAKA,gBAEA,qBACA,aAEA,kBACA,EAEA,UACA,OAEA,SACA,OACA,KACA,EAEA,aACA,qBACA,UAGA,mBAEA,OACA,MAEA,MACA,QACA,SACA,IACS,WACT,QACA,MAGA,iBACA,cACA,EAEA,OACA,GAWA,CACA,qBACA,SAEA,kBACA,+BAGA,MACA,IAHA,WAMA,MACA,SAEA,0BAEA,OACA,QACA,MACA,EAEA,SAGA,KAEA,KACA,KAEA,cACA,2BACA,+CAEA,IACA,KACA,KAGA,yBACA,GAEA,UACA,OAEA,SACA,OACA,KACA,KACA,CAEA,IACA,SACA,GAGA,8BACA,OAEA,QACA,MAEA,MACA,QACA,SACA,IAEA,WACA,MACA,EAEA,KAEA,OACA,GAUA,CACA,mBACA,mCACA,GAEA,uBAnOA,eACA,oBACA,iBACA,sBAGA,mBACA,gBACA,4BAEA,gEAEA,mCACA,4BACA,wBAEA,uEACA,0BACA,wBAGA,yCACA,OACA,OACA,IACA,IACA,CAEA,wCACA,uCACA,yBAEA,kDACA,0BAEA,8EAEA,+CAEA,0BACA,EAWA,EAiLA,W,mB2B7PA,kBAGA,kDACA,iCCJA,aAEA,MASA,WACA,kBACA,yBACA,OACA,UAAmB,MAAiB,OACpC,kBAEA,QACA,IAhBA,YAOA,mBCDA,aAsBA,UArBA,aACA,WACA,yBAAoC,+BAGpC,sBAAmB,IAAY,EAC/B,cAAuB,KAAQ,EAC/B,qBAKA,cAAmB,IAAY,EAC/B,gBAA2B,IAAY,EACvC,iBAIA,SACA,qBC7BA,aAgSA,iBACA,OACA,SAEA,iBACA,sBACA,SAEA,oBACA,wBACA,mBAEA,oBACA,wBACA,mBA5SA,UAEA,OACA,QACA,cAEA,eACA,IACA,IAEA,EAIA,QACA,aAA4B,MAC5B,iBACA,IAYA,2BAXA,8BACA,4BACA,8BACA,oCACA,+BACA,6BACA,iCACA,wCACA,oDAfA,OAmBA,mBACA,0EAAiF,EAGjF,yCAtBA,KAuBA,kDACA,uBACA,qDAA2D,EAE3D,cACA,qDAA2D,EAE3D,WACA,0CAAmD,EAAc,yCAAwC,EAGzG,YAIA,MACA,aACA,gBAEA,mBACA,oBACA,mBAEA,sBACA,2BACA,EAEA,EAGA,iBACA,mBAEA,qBACA,+BACA,cAEA,QACA,eACA,KAEA,WACA,aACA,QAEA,QACA,0BACA,gBACA,cACA,GAEA,WACA,8BACA,OACA,KAKA,cAJA,kBACA,0CAIA,oDACA,kCACA,gBACA,GAEA,mBACA,mBACA,4BACA,6BACA,OAEA,8BACA,oDACA,2BACA,GAEA,CACA,QAEA,cACA,0BACA,YAEA,uBACA,OAEA,oBAGA,yBAEA,cACA,0BACA,YAEA,uBACA,OAEA,oBAGA,yBAEA,sBACA,oCACA,kDACA,2BACA,GACA,CAEA,gBACA,OACA,uBAEA,eACA,eACA,cACA,oBAEA,UACA,wBACA,aACA,kBAEA,qCACA,SACA,cAGA,uBACA,EACA,EAEA,kBACA,OACA,yBAEA,iBACA,eACA,eAEA,iBAAuB,QAAkB,OACzC,6BACA,SAIA,WACA,CAEA,qBACA,eACA,cACA,YAGA,UACA,wBACA,aACA,kBAEA,wBACA,QACA,cAGA,kBACA,UACA,0CACA,SACA,cAEA,oBACA,GAEA,iBACA,MAGA,EACA,EAEA,mBACA,yBACA,YACA,gBACA,GACA,CAEA,WACA,qBAEA,4CAEA,4BACA,cACA,eAEA,cACA,WACA,WAEA,+BACA,4CAEA,0BACA,eACA,cACA,4BAEA,oBAAuB,KAAiB,GACxC,mBACA,WACA,6BACA,WACA,aACA,WACA,CAEA,CAEA,eACA,YAAuB,gBAAuB,OAC9C,yBACA,uBAGA,SACA,QAEA,iBACA,YAAuB,gBAAuB,OAC9C,yBACA,wBAGA,SACA,QAEA,gBACA,YAAuB,gBAAuB,OAC9C,yBACA,uCAGA,SACA,QACA,EAEA,8BC9RA,UACA,WAEA,MAEA,aAEA,CAGA,oEACA,wEACA,wCAGA,gFACA,iFACA,UAGA,oFACA,yEACA,WAGA,sFACA,yEAGA,iFACA,4EACA,oBAGA,kFACA,iFAGA,+EACA,gFACA,UAGA,kFACA,0EACA,8BAGA,kFACA,6EACA,oBAGA,+EACA,iFACA,UAGA,6EACA,yEACA,8BAGA,4BACA,kDACA,0EACA,8BAGA,+DACA,6DACA,0DACA,YAEA,UAUA,YARA,WACA,aACA,SACA,UAEA,KACA,IAGA,kCCrFA,aAcA,oBACA,QACA,aAAmB,QAAqB,OACxC,mBAAuB,QAAqB,OAC5C,sBACA,oBAGA,UACA,GAQA,CACA,oBACA,aACA,KAAmB,QAAqB,OACxC,mBAAuB,QAAqB,OAC5C,sBACA,oBAGA,UACA,GAQA,CACA,oBACA,YACA,KAAmB,QAAqB,OACxC,gBAAuB,QAAqB,OAC5C,uBAGA,6BACA,OAQA,CACA,oBACA,+BACA,WAAmB,QAAqB,OACxC,gBAAuB,QAAqB,OAC5C,uCAGA,cACA,GAQA,CACA,oBACA,gBACA,sCACA,QAEA,iBACA,WACA,GAEA,iBACA,eACA,OACA,2BAEA,cACA,wBACA,SACA,SAEA,yBAEA,IAvGA,UACA,OACA,OACA,OAQA,IA8FA,OACA,SACA,OACA,SAUA,qBA0HA,UAzHA,eACA,WAA8B,aAC9B,cACA,UACA,SACA,8BAKA,UACA,mCACA,UACA,iBACA,EACA,UACA,mBACA,EACA,UACA,kBACA,EACA,UACA,mBACA,EACA,UACA,eACA,EACA,MACA,6BAEK,uCACL,+CAGA,iDACA,OAAmB,QAAqB,OACxC,kBAEA,WACA,QACA,SAEA,eAEA,CACA,MACA,kBAAuB,QAAiB,OACxC,mBAA+B,QAAiB,YAChD,QACA,sBACA,cACiB,WACjB,uBACA,mBAAmC,QAAsB,OACzD,6BAEA,KACA,oBACA,cACiB,WACjB,uBACA,mBAAmC,QAAsB,OACzD,6BAEA,KACA,8BACA,QACA,2BAEA,yBAEA,qBACA,GAGA,QAGA,qBAFA,gBACA,WAEA,eACA,OACA,sBAA2B,QAAiB,OAC5C,qCAEA,QACA,kBACA,eACA,kCAEA,QACA,kBACA,gBACA,mBACA,EAEA,UACA,EACA,WAEA,iBAAwB,QAAuB,YAC/C,OACA,sBACA,qBACA,kBACA,eACA,KAA4B,YAA2B,OACvD,yBACA,yBAEA,0BACA,2CAEA,yCAEA,mBACA,WACA,GACA,CACA,WACA,qBChPA,aAaA,oBACA,QACA,aAAmB,QAAqB,OACxC,mBAAuB,SAAqB,OAC5C,qBACA,oBAGA,UACA,GAQA,CACA,oBACA,aACA,KAAmB,QAAqB,OACxC,mBAAuB,SAAqB,OAC5C,qBACA,oBAGA,UACA,GAQA,CACA,oBACA,YACA,KAAmB,QAAqB,OACxC,gBAAuB,QAAqB,OAC5C,sBAGA,6BACA,OAQA,CACA,oBACA,YACA,KACA,KACA,KACA,KAAmB,QAAqB,OACxC,gBACA,cAEA,cAAmB,QAAqB,OACxC,gBACA,cAEA,iBACA,cACA,cACA,cACA,sBACA,IAQA,CACA,oBACA,YACA,KACA,KACA,KACA,KAAmB,QAAqB,OACxC,gBACA,cAEA,cAAmB,QAAqB,OACxC,gBACA,cAEA,iBACA,cACA,cACA,cACA,6DACA,OASA,CACA,oBACA,YACA,GACA,IAGA,kBACA,WAAmB,WAAyB,OAC5C,qBAEA,4BACA,WAAmB,WAAyB,OAC5C,qBAGA,gBACA,MAAmB,QAAe,YAClC,IACA,aAAuB,QAAe,OACtC,UACA,sBAGA,oBACA,KACA,aAAuB,QAAe,OACtC,sBAEA,YACA,gBACA,YACA,QAEA,GACA,OACA,IAeA,oBACA,YACA,KACA,KAAmB,QAAkB,OACrC,gBAAuB,SAAkB,OACzC,uCACA,QAGA,eACA,EAOA,CA1LA,UACA,OACA,OAQA,GAkJA,MACA,MACA,OAUA,UAuIA,UApHA,eACA,cAA8B,YAC9B,IACA,mCACA,UACA,iBACA,EACA,UACA,mBACA,EACA,UACA,kBACA,EACA,UACA,mBACA,EACA,UACA,eACA,EACA,MACA,6BAEK,uCACL,+CAEA,0CACA,wBACA,0BACA,mBAAqB,QAAmB,OACxC,2BACA,uBAGA,iCACA,oBACA,MACA,OACA,iBACA,IACA,KACA,aAAuB,QAAiB,YACxC,IACA,aAA2B,YAAoB,OAC/C,mBAAqC,YAAoB,OACzD,gFAGA,OACA,QACA,MAEA,GACA,OACA,EACA,sEACA,yEACS,wCACT,+DACA,WACA,sDACA,6DAEA,uCACA,CAAS,KACT,eACA,SACA,0BACA,eAA6B,WAA2B,OACxD,eAEA,cAA4B,WAA0B,YACtD,IACA,aAAgC,WAA0B,OAC1D,UACA,8EAGA,0BACA,KACA,QACA,MAEA,GACA,YACA,oBACA,iBACA,MACA,4BACA,sBACA,iBAEA,yBACA,6BACA,mBAA2B,QAAkB,OAC7C,uCACA,uCACA,wCAEA,wBACA,6BACA,mBAA2B,QAAkB,OAC7C,uCACA,uCACA,wCAEA,kCACA,mCACA,cACA,YACA,wBACA,GACA,cACA,EACA,OACA,sBC/SA,aAEA,cACA,UAGA,qBCNA,aAKA,aACA,qBACA,iBAEA,sBACA,MACA,8BAGA,mCAMA,IALA,MACA,eACA,GACA,WAEe,IAAe,MAC9B,SACA,KACA,QAAmB,IAAO,MAC1B,UACA,MACA,QAAuB,IAAO,EAC9B,gBAEA,6BACA,SACA,EAEA,eAEA,KACA,iCACA,QAAuB,IAAe,EACtC,YAEA,CAEA,KACA,kBAGA,0CACA,EA7CA,WAEA,OA6CA,YACA,4BACA,aACA,CACA,mBACA,iBAEA,cACA,MAEA,iBACA,kBAGA,0CAIA,MAHA,YACA,cAEmB,IAAe,EAClC,UAAuB,IAAW,MAClC,OAA2B,IAAO,EAClC,0BAEA,iBACA,EAGA,SAA+B,EAAQ,KACvC,UAAuB,IAAW,MAClC,SAA+B,IAAe,EAC9C,0BAEA,iBACA,EAGA,OACA,EACA,GAEA,6BCzFA,aAYA,gBACA,cAA8B,YAC9B,qBACA,mBAEA,uBACA,MACA,2BAGA,wCAOA,QANA,mBACA,YACA,aACA,OACA,EAGA,iBAGA,mBAGA,iBACA,QAAmB,KAAO,GAC1B,YAAuB,KAAO,GAC9B,0BAGA,eACA,eACA,GAAK,KACL,gBACA,YACA,WAAmB,KAAO,GAC1B,YAAuB,KAAO,GAC9B,0BAGA,eACA,kBACA,GAEA,QACA,UACA,UACA,UACA,GAoCA,sBAEA,oBACA,MAEA,UAAe,KAAO,EACtB,oBAGA,aAAmB,EAAO,UAC1B,QACA,KACA,KAAmB,KAAO,GAC1B,qBAGA,QACA,wBACA,MAAuB,KAAO,GAC9B,qBACA,eACA,aAES,MACT,QAAuB,KAAO,GAC9B,aACA,iBAGA,iBACA,gBACA,IACA,WAGA,cACA,UACA,eACA,MAAuB,KAAO,GAC9B,YAGA,SAAuB,KAAO,QAC9B,WACA,eACA,wBACA,SAA+B,SAAY,EAC3C,uBACA,uBAEA,UACA,EAEA,QACA,KAAuB,KAAO,GAC9B,aACA,iBAGA,kBACA,OAAuB,KAAO,GAC9B,mBAGA,WAAuB,KAAO,QAC9B,WACA,UACA,OAA2B,UAAY,EACvC,iCAEA,oBACA,eACA,CACA,CACA,QACA,EAEA,QAAe,OAAW,OAC1B,uBACA,eACA,WACA,UACA,QAAuB,MAAQ,GAC/B,yBAGA,UAAuB,MAAQ,QAC/B,QACA,KAA2B,MAAQ,GACnC,6BAEA,WAA2B,MAAQ,GACnC,uBAEA,GACA,CAEA,QAAmB,MAAQ,GAC3B,kBAEA,CAEA,QAAe,KAAO,EACtB,oBACA,gBAGA,eACA,QACA,EAEA,sBAEA,6BACA,qBACA,GAEA,UAAe,KAAO,EACtB,iBAGA,YAEA,SACA,KACA,EAEA,gCAAe,KAAO,OACtB,iDACA,SACA,MACA,0BAGA,KAGA,cACA,IACA,IAGA,gBACA,2BACA,aACA,GACA,WAGA,sBACA,wBACA,aACA,YACA,UAA+B,KAAO,EACtC,aAGA,WAEA,SACA,OACA,KACA,MACA,YACA,MACA,KACA,QAA+B,MAAQ,GACvC,YACA,MACA,MACA,YACA,UACA,cACA,iBACA,aACA,SACA,mBACA,+BAEA,QAA+B,KAAO,EACtC,kBACA,iCACA,+BAIA,0BACA,aACA,aAEA,EACA,2BACA,GACA,SACA,UACA,CAEA,QAAe,OAAW,OAC1B,QACA,SACA,UAAuB,KAAO,EAC9B,YACA,QACA,SAIA,aACA,iBACA,WACA,MAAuB,KAAO,EAC9B,eACA,sBACA,eAGA,EACA,EAEA,sBAEA,oBAGA,GAEA,MAJA,OACA,YAGqB,SAAe,OACpC,QACA,KAAmB,OAAW,GAC9B,4BAGA,cACA,QACA,KAA0B,OAAQ,GAClC,yBACA,iBAGA,qBACA,IACA,eAGA,eACA,WAEA,MAAuB,MAAO,OAC9B,QACA,KAA8B,OAAQ,GACtC,uBAGA,YACA,MAA2B,OAAW,GACtC,uBAEA,GAEA,QAAuB,MAAW,QAClC,QACA,KAA8B,OAAQ,GACtC,uBAGA,YACA,MAA2B,OAAW,GACtC,uBAEA,GAEA,cACA,oBACA,EACA,CAEA,QAAe,KAAO,EACtB,YAAmB,KAAO,EAC1B,0BAIA,YAAsB,SAAc,EACpC,yBACA,WAA2B,MAAW,GACtC,sBAGA,UAAuB,OAAW,QAClC,QACA,KAA2B,OAAW,GACtC,uBAGA,+BACA,MAA2B,OAAW,GACtC,uBAEA,GACA,CAEA,EAEA,yBACA,6BAaA,YACA,MAEA,QAfA,KACA,OACA,EACA,4BACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,SAIe,KAAQ,EACvB,oBACA,oBACA,WAGA,oBAAoC,MAAQ,EAC5C,yBAIA,kBACA,QACA,MACA,iDACA,KACA,YAEA,gCAGA,MAGA,aACA,eACA,iBACA,WACA,EACA,QACS,oBACT,6BACA,mCACA,WACA,yBACA,iBACA,iCACA,aAEA,UACA,uBACA,eACA,gBACA,GACA,sBAEA,aACA,SACA,eACA,4BACA,UACA,SACA,yBACA,QACA,OAEA,SAA+B,KAAQ,EACvC,iBACA,iCACA,gCAGA,UAA2B,MAAQ,GACnC,kBACA,gCACA,gCAGA,UAA6B,OAAW,GACxC,kBACA,gCACA,gCAEA,EACA,kBACA,aACA,YACA,WAGA,OACA,KACA,CAAS,KACT,cACA,OACA,KACA,KACA,oBACA,4BAGA,YACA,SACA,MAA6B,OAAQ,GACrC,iBAEA,kDACA,eACA,iBACA,EAEA,IACA,oBACA,WACA,SACA,kBACA,OACA,SAEA,wBACA,OAAiC,OAAQ,GACzC,iBAEA,OACA,YACA,KAKA,gBACA,MACA,eACA,UACA,SACA,wCACA,2BACA,kBACA,yCACA,QACA,OACA,OACA,QAGA,uIAGA,QAGA,eAA2B,MAAQ,GACnC,kBACA,QACA,iBAIA,UAAuB,UAAY,eAEnC,OACA,kBACA,kBACA,wBACA,wCACA,IACA,aACA,OACA,OAIA,KAIA,QAjBA,oCAkBA,IACA,WAGA,WACA,UACA,QAEA,6BAGA,qBAJqB,OAKrB,SACA,SACA,SACA,OACA,OAEA,MAA+B,MAAQ,EACvC,+BACA,IACA,qBACA,iCAGA,mBACA,gCAGA,UAA+B,qBAAyB,GACxD,mCACA,GACA,sBACA,gCAGA,gBACA,gCAGA,UAAiC,OAAW,GAC5C,mCACA,GACA,sBACA,gCAGA,gBACA,gCAEA,EAEA,CACA,CAEA,IAIA,iBAAoB,EAAQ,MAC5B,cACA,UAEA,IACA,cACA,cACA,QAA2B,EAAQ,WACnC,mBACA,MACA,KAA2B,OAAQ,GACnC,2BAGA,OACA,YACA,MAEA,cACA,GACA,qCAEA,yBACA,eACA,yCACA,qBACA,cACA,qEAGA,uBACA,KACA,kBAAmC,OAAQ,GAC3C,iBAIA,EACS,SACT,eAEA,2CACA,kCACA,2CAEA,4CACA,sBACA,mBAGA,iBACA,aACA,QAA2B,EAAQ,WACnC,QACA,KACA,KAA2B,OAAQ,GACnC,8BACA,yBAGA,qBAEA,GACA,YACA,MACA,MAEA,cACA,GACA,4BACA,oBACA,iBAEA,kBACA,eACA,gDACA,oBACA,WACA,gFAEA,kDACA,oBACA,iBACA,sCACA,wDACA,oDAEA,mDACA,sBACA,mBAIA,wDACA,MACA,kBAAmC,OAAQ,GAC3C,+BACA,eAIA,EAIA,QAAe,KAAQ,EACvB,kBACA,UAAuB,MAAQ,EAC/B,uBAKA,aAAoB,MAAU,GAC9B,YAAqB,OAAW,QAChC,QACA,KAAyB,mBAAwB,IACjD,2BAEA,eACA,EAEA,GAEA,sBACA,QACA,gCACA,WACA,YACA,2BAEA,YACA,YACA,2BAEA,KAvwBA,aACA,WACA,OACA,eAEA,mBACA,CAGA,oBAmDA,YACA,sBACA,aACA,CACA,4BACA,aACA,CACA,yBACA,wBACA,uBAEA,SACA,CACA,sBACA,QAKA,UAJA,UACA,UACA,aACA,UACmB,KAAO,OAC1B,QAAuB,KAAO,EAC9B,gBAEA,gBACA,IACA,yBACa,IACb,2BAEA,IACA,OACA,GACA,GA6qBA,6BC3wBA,aAMA,aACA,qBACA,iBAEA,mBAEA,aAMA,MALA,YACA,SACA,gBACA,SAEe,IAAO,MACtB,QACA,QAAmB,IAAO,EAC1B,iBAEA,cACA,KACA,gBAEA,MAAuB,IAAO,EAC9B,aAEA,gBACA,MAA2B,IAAO,MAClC,OACA,IAA2B,IAAO,EAClC,oBAEA,iBACA,KAA2B,IAAO,EAClC,oBAEA,EACA,CACA,OACA,EAEA,SACA,aACA,EA7CA,WACA,cAEA,WA4CA,YACA,kBACA,iBAEA,cACA,OAEA,iBACA,kBAEA,6CACA,6BAGA,oCACA,YACA,YACA,cAEA,SAAmB,IAAO,EAC1B,UAAuB,IAAW,MAClC,QACA,IAA2B,IAAO,EAClC,qBAEA,mBACA,KAA2B,IAAO,EAClC,qBAEA,EAEA,SAAuB,EAAQ,SAC/B,OAAuB,IAAW,EAClC,wBAEA,SAAuB,IAAO,EAC9B,UAA2B,IAAW,EACtC,0BAGA,EAEA,8BACA,EACA,uBACA,mBACA,UAAuB,IAAa,EACpC,OACA,kBAGA,SACA,QACA,6BACA,OAIA,SAHA,OACA,kBACA,SACmB,IAAO,EAC1B,UAAuB,IAAO,EAC9B,cACA,OACiB,OACjB,aAEA,GAIA,QACA,EACA,wBACA,WAMA,SALA,OACA,SACA,kBACA,WAE6B,EAAQ,SACrC,OAAuB,IAAU,EACjC,YAEA,cACA,IAAuB,IAAa,EACpC,mBACA,OACA,IAA+B,IAAU,EACzC,oBAGA,iBAEA,KAA+B,IAAU,EACzC,oBAEA,EAEA,CACA,OACA,EACA,GAEA,6BCvJA,aAUA,aACA,wBACA,eACA,MASA,CAeA,eACA,wBACA,mBACA,iDACA,GAvCA,WAEA,WACA,QACA,QACA,QACA,YAeA,gBASA,EACA,8CACA,UACA,OAQA,UACA,6BACA,eACA,IAEA,UACA,4BACA,MACA,0BACA,MACA,kBACA,KACA,kBACA,KACA,wBACA,MACA,UACA,QACA,eC3DA,oBACA,oCACA,+BCJA,aAEA,WAkBA,UAhBA,eACA,iBACA,gBACA,eACA,CAEA,WACA,sCACA,GACA,IAEA,OACA,+BACA,OACA,oBClBA,aAEA,WAiBA,UAfA,eACA,eACA,kBACA,QAEA,WACA,2CACA,GACA,IAEA,SACA,yCACA,EACA,oBCjBA,aAEA,WAiBA,UAfA,eACA,eACA,kBACA,QAEA,WACA,wCACA,GACA,IAEA,SACA,sCACA,EACA,oBCjBA,aAEA,WAkBA,UAhBA,eACA,iBACA,aACA,kBACA,CAEA,WACA,mCACA,GACA,IAEA,SACA,iCACA,EACA,oBClBA,aAEA,QACA,UAoBA,UAlBA,eACA,mBACA,0BACA,iCACA,0BACA,yBACA,MAEA,WACA,iEACA,GACA,IAEA,SACA,8DACA,GACA,oBCrBA,aAEA,QACA,UAoBA,UAlBA,eACA,uBACA,sBACA,qBACA,iBACA,mBACA,CAEA,WACA,2DACA,GACA,IAEA,SACA,yDACA,EACA,oBCrBA,aAEA,WAiBA,UAfA,eACA,eACA,qBACA,KAEA,WACA,4BACA,GACA,IAEA,SACA,0BACA,EACA,gBCdA,aA6DA,aACA,kCACA,IACA,aACA,SACA,EAEA,gBAAkB,IAClB,SAEA,aACA,EACA,UACA,iBAEA,aACA,OAAsB,IACtB,SACA,aACA,QAA2B,OAC3B,KAEA,mBAEA,QACA,OACA,EAEA,gBACA,WAAmB,IAAU,IAC7B,mBACA,iBAGA,0BAGA,sBACA,iBACA,QAEA,EACA,CACA,OACA,E,CAvGA,QACA,WACA,MAEA,cACA,uBACA,gBAAoC,YACpC,aACA,KACA,0BAGA,iCACA,aACA,uBACA,MACA,MAAwB,IACxB,gBAA4B,IAC5B,sBACA,UAEA,EAGA,MACA,EAEA,wCACA,gBACA,gBAAgB,WAChB,WACA,UAAoB,cACpB,IACA,uBAIA,uBACA,iBACA,cAAuB,cACvB,0BACA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CAGA,EACA,cACA,QAEA,iCAGA,oBACA,sBACA,0BAEA,OAEA,UACA,GAAK,UACL,IAEA,oBACA,GAAS,UAGT,oBACA,GACA,CAIA,EAMA,YACA,IAGA,KACA,QACA,mBAEA,OAEA,IACA,QAEA,KAEA,YACA,KAGA,YACA,GAEA,kBACA,WACA,QACA,EACA,UACA,IACA,WAGA,UACA,OACA,MACA,IACA,KACA,OACA,KAgBA,iBACA,UACA,cACA,GAWA,cAhKA,QAOA,WACA,eASA,IACA,GACA,8BAEA,WAEA,CAAK,UACL,GACA,CACA,IACA,GACA,gCAEA,aAEA,CAAK,UACL,GACA,CACA,CAAC,KAqDD,GACA,MACA,KACA,SAyCA,uBACA,+BACA,MACA,8BAAuB,eAAsB,OAC7C,wBAGA,oBACA,mBACA,KAEA,EAEA,EAKA,0BACA,0BACA,QACA,kBACA,aACA,SACA,UACA,UAAqB,GACrB,cAIA,OACA,gBACA,SACA,QACA,mBACA,uBACA,SAEA,oBACA,iBACA,qCAEA,gBAA2B,YAC3B,kBACA,iBACA,mCACA,kBAA4B,OAAU,gBCnLtC,WAEA,8CACA,UACA,wCACA,aACA,OACA,EACA,cACA,YAGA,kBAGA,eACA,UACA,mBACA,gBACA,yBACA,2BACA,CACA,eCtBA,qBACA,WACA,oBACA,2BACA,2BACA,8B,kBCLA,eAmBA,CAyGA,iBAEA,QACA,CACA,gBAGA,mDACA,8CACA,OAEA,kBACG,GAEH,iBAGA,2BACA,uCACA,sBACA,qCACA,yCACA,cACA,OAmCA,iBACA,iBAEA,UACA,gCACA,2BAEA,IAEA,GAGA,cACA,OACA,IAGA,cACA,IAEA,qCACA,IACA,MAEA,GACA,GAGA,oBAGA,OACA,eACA,UAEA,yBAEA,0DACA,sBACA,cACA,iBAEA,KACA,EAGA,aACA,OACA,SAIA,uBACA,SAEA,UACA,2CAKA,QACA,gCACA,uCAIA,qBACA,WACA,6BACA,wCACA,UACA,OACA,yDAEA,gBACA,uDAEA,cACA,aAEA,GAEA,iBAGA,mBACA,MACA,MAIA,qBACA,6BACA,sBACA,GAGA,OACA,4CAIA,QACA,6CAIA,QACA,eAGA,0BACA,iCAGA,MACA,eACA,kDAEA,gCAIA,wBAEA,OACA,cACA,iBAEA,uBACA,yBACA,GAGA,WAEA,cACA,IAGA,iBACA,OACA,kCACA,uBACA,iDACA,iBACA,4BACA,0BACA,SACA,WACA,qBACA,aACA,qBAEA,cACA,sBACA,eAGA,cACA,6CACA,IAGA,0BACA,QACA,kBAAmC,UAAO,GAC1C,WACA,0BACA,GAEA,mBAGA,kCACA,UACA,6BACA,GAEA,OACA,GACA,GAGA,6BACA,WACA,iDAAyD,UACzD,QACA,OACA,oCAEA,oCAGA,cACA,+BAGA,kBACA,gBAEA,KACA,KACA,mCACA,kBAEA,uBAEA,IACA,qBACA,qCACA,YACA,EAAW,qBAEX,0CACA,aACA,EAAW,QAIX,mCAGA,mBACA,iBACA,eAEA,yBACA,aACA,0DACA,oBAEA,6BACA,uBACA,wBACA,uBAEA,UAEA,gBACA,GAGA,oBACA,QACA,8BACA,OACA,2BACA,gDACA,CAAG,EAEH,SACA,UACA,kBACA,OACA,YACA,SACA,OAGA,qCACA,EAIA,CACA,eACA,sBACA,IAGA,eACA,OACA,qBAGA,eACA,OACA,WAQA,eACA,OACA,oBAGA,eACA,OACA,oBAQA,eACA,YACA,QAGA,eACA,gBACA,2BAGA,eACA,4BACA,UAGA,eACA,gBACA,yBAGA,eACA,WACA,8CACA,QAGA,eACA,OACA,sBAeA,eACA,uCACA,IAGA,eACA,8CACA,IAOA,aACA,WACA,gBACA,kBACA,wCACA,oDACA,IAGA,CAiCA,kBACA,gDACA,IApjBA,kBACA,qBACA,YACA,QACA,UAAmB,eAAsB,OACzC,yBAEA,qBACA,IAEA,YACA,KACA,gBACA,yCACA,oBACA,oBACA,WACA,uBACA,4BACA,UACA,QACA,0BACA,MAAS,UACT,OACA,YACA,CACA,cAEA,KACA,SAAuB,OAAS,SAChC,sBACA,QAEA,SAGA,UACA,GAKA,EACA,2BAEA,SACA,0BACA,sCACA,UAGA,YACA,oBAGA,OACA,OAeA,iBAdA,QACA,MACA,iCACO,WACP,+BAEA,kBAEA,IACA,KACA,sBACA,UAEA,GAIA,GACA,UACA,uBACA,OACA,2BACA,UACA,kBACA,+CACA,UACA,qBACA,yBACA,2CACA,GACA,CACA,wBAGA,YACA,GAUA,EAyBA,UAGA,EACA,EAgBA,+LACA,EAUA,mIAiRA,aAKA,eAKA,YAKA,oBAHA,YACA,OACA,WAMA,cAKA,cAKA,WAHA,YACA,OACA,qBAMA,iBAKA,cAKA,cAKA,YAMA,aAKA,gBAUA,cARA,YACA,OACA,YACA,sBACA,qBACA,qBACA,qBACA,wBAGA,iBAYA,GAGA,8EAWA,gBACA,6CACA,WAeA,EACA,iBAEA,yBAEA,uBAEA,2BACA,UACA,OACA,uBAEA,WACA,wCCrkBA,GAGA,aACA,OACA,KAAC,IAED,GAEA,0CACA,OAAC,SAED,CACA,4BACA,OAI4C,CAE5C,6BCpBA,aAEA,EAAQ,WAAa,EAAQ,IAC7B,EAAQ,WAAa,EAAQ,IAC7B,EAAQ,WAAa,EAAQ","file":"nmr-simulation.min.js","sourcesContent":["'use strict';\n\n/**\n *\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * @param x - sorted increasing x values\n * @param y\n * @param options\n * @returns {Array} new array with the equally spaced data.\n *\n */\nfunction getEquallySpacedData(x, y, options) {\n    if (x.length>1 && x[0]>x[1]) {\n        x=x.slice().reverse();\n        y=y.slice().reverse();\n    }\n\n    var xLength = x.length;\n    if(xLength !== y.length)\n        throw new RangeError(\"the x and y vector doesn't have the same size.\");\n\n    if (options === undefined) options = {};\n\n    var from = options.from === undefined ? x[0] : options.from\n    if (isNaN(from) || !isFinite(from)) {\n        throw new RangeError(\"'From' value must be a number\");\n    }\n    var to = options.to === undefined ? x[x.length - 1] : options.to;\n    if (isNaN(to) || !isFinite(to)) {\n        throw new RangeError(\"'To' value must be a number\");\n    }\n\n    var reverse = from > to;\n    if(reverse) {\n        var temp = from;\n        from = to;\n        to = temp;\n    }\n\n    var numberOfPoints = options.numberOfPoints === undefined ? 100 : options.numberOfPoints;\n    if (isNaN(numberOfPoints) || !isFinite(numberOfPoints)) {\n        throw new RangeError(\"'Number of points' value must be a number\");\n    }\n    if(numberOfPoints < 1)\n        throw new RangeError(\"the number of point must be higher than 1\");\n\n    var algorithm = options.variant === \"slot\" ? \"slot\" : \"smooth\"; // default value: smooth\n\n    var output = algorithm === \"slot\" ? getEquallySpacedSlot(x, y, from, to, numberOfPoints) : getEquallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n    return reverse ? output.reverse() : output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nfunction getEquallySpacedSmooth(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    var initialOriginalStep = x[1] - x[0];\n    var lastOriginalStep = x[x.length - 1] - x[x.length - 2];\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = Number.MIN_VALUE;\n    var previousY = 0;\n    var nextX = x[0] - initialOriginalStep;\n    var nextY = 0;\n\n    var currentValue = 0;\n    var slope = 0;\n    var intercept = 0;\n    var sumAtMin = 0;\n    var sumAtMax = 0;\n\n    var i = 0; // index of input\n    var j = 0; // index of output\n\n    function getSlope(x0, y0, x1, y1) {\n        return (y1 - y0) / (x1 - x0);\n    }\n\n    main: while(true) {\n        while (nextX - max >= 0) {\n            // no overlap with original point, just consume current value\n            var add = integral(0, max - previousX, slope, previousY);\n            sumAtMax = currentValue + add;\n\n            output[j] = (sumAtMax - sumAtMin) / step;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            sumAtMin = sumAtMax;\n        }\n\n        if(previousX <= min && min <= nextX) {\n            add = integral(0, min - previousX, slope, previousY);\n            sumAtMin = currentValue + add;\n        }\n\n        currentValue += integral(previousX, nextX, slope, intercept);\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else if (i === xLength) {\n            nextX += lastOriginalStep;\n            nextY = 0;\n        }\n        // updating parameters\n        slope = getSlope(previousX, previousY, nextX, nextY);\n        intercept = -slope*previousX + previousY;\n    }\n\n    return output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nfunction getEquallySpacedSlot(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n    var lastStep = x[x.length - 1] - x[x.length - 2];\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = -Number.MAX_VALUE;\n    var previousY = 0;\n    var nextX = x[0];\n    var nextY = y[0];\n    var frontOutsideSpectra = 0;\n    var backOutsideSpectra = true;\n\n    var currentValue = 0;\n\n    // for slot algorithm\n    var currentPoints = 0;\n\n    var i = 1; // index of input\n    var j = 0; // index of output\n\n    main: while(true) {\n        if (previousX>=nextX) throw (new Error('x must be an increasing serie'));\n        while (previousX - max > 0) {\n            // no overlap with original point, just consume current value\n            if(backOutsideSpectra) {\n                currentPoints++;\n                backOutsideSpectra = false;\n            }\n\n            output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            currentValue = 0;\n            currentPoints = 0;\n        }\n\n        if(previousX > min) {\n            currentValue += previousY;\n            currentPoints++;\n        }\n\n        if(previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1)\n            currentPoints--;\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else {\n            nextX += lastStep;\n            nextY = 0;\n            frontOutsideSpectra++;\n        }\n    }\n\n    return output;\n}\n/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n *\n * @param x0\n * @param x1\n * @param slope\n * @param intercept\n * @returns {number} integral value.\n */\nfunction integral(x0, x1, slope, intercept) {\n    return (0.5 * slope * x1 * x1 + intercept * x1) - (0.5 * slope * x0 * x0 + intercept * x0);\n}\n\nexports.getEquallySpacedData = getEquallySpacedData;\nexports.integral = integral;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/getEquallySpaced.js\n// module id = 24\n// module chunks = 0","'use strict';\n\nconst Matrix = require('ml-matrix');\n\nlet defOptions = {'H': {frequency: 400, lineWidth: 10}, 'C': {frequency: 100, lineWidth: 10}};\n\nfunction simule2DNmrSpectrum(table, options) {\n    var i;\n    const fromLabel = table[0].fromAtomLabel;\n    const toLabel = table[0].toLabel;\n    const frequencyX = options.frequencyX || defOptions[fromLabel].frequency;\n    const frequencyY = options.frequencyY || defOptions[toLabel].frequency;\n    var lineWidthX = options.lineWidthX || defOptions[fromLabel].lineWidth;\n    var lineWidthY = options.lineWidthY || defOptions[toLabel].lineWidth;\n\n    var sigmaX = lineWidthX / frequencyX;\n    var sigmaY = lineWidthY / frequencyY;\n\n    var minX = table[0].fromChemicalShift;\n    var maxX = table[0].fromChemicalShift;\n    var minY = table[0].toChemicalShift;\n    var maxY = table[0].toChemicalShift;\n    i = 1;\n    while (i < table.length) {\n        minX = Math.min(minX, table[i].fromChemicalShift);\n        maxX = Math.max(maxX, table[i].fromChemicalShift);\n        minY = Math.min(minY, table[i].toChemicalShift);\n        maxY = Math.max(maxY, table[i].toChemicalShift);\n        i++;\n    }\n\n    if (options.firstX !== null && !isNaN(options.firstX)) {\n        minX = options.firstX;\n    }\n    if (options.firstY !== null && !isNaN(options.firstY)) {\n        minY = options.firstY;\n    }\n    if (options.lastX !== null && !isNaN(options.lastX)) {\n        maxX = options.lastX;\n    }\n    if (options.lastY !== null && !isNaN(options.lastY)) {\n        maxY = options.lastY;\n    }\n\n    var nbPointsX = options.nbPointsX || 512;\n    var nbPointsY = options.nbPointsY || 512;\n\n    var spectraMatrix = new Matrix(nbPointsY, nbPointsX).fill(0);\n    i = 0;\n    while (i < table.length) {\n        //parameters.couplingConstant = table[i].j;\n        //parameters.pathLength = table[i].pathLength;\n        let peak = {\n            x: unitsToArrayPoints(table[i].fromChemicalShift, minX, maxX, nbPointsX),\n            y: unitsToArrayPoints(table[i].toChemicalShift, minY, maxY, nbPointsY),\n            z: table[i].fromAtoms.length + table[i].toAtoms.length,\n            widthX: unitsToArrayPoints(sigmaX + minX, minX, maxX, nbPointsX),\n            widthY: unitsToArrayPoints(sigmaY + minY, minY, maxY, nbPointsY)\n        };\n        addPeak(spectraMatrix, peak);\n        i++;\n    }\n    return spectraMatrix;\n}\n\nfunction unitsToArrayPoints(x, from, to, nbPoints) {\n    return ((x - from) * nbPoints - 1) / (to - from);\n}\n\nfunction addPeak(matrix, peak) {\n    var nSigma = 4;\n    var fromX = Math.max(0, Math.round(peak.x - peak.widthX * nSigma));\n    var toX = Math.min(matrix[0].length - 1, Math.round(peak.x + peak.widthX * nSigma));\n    var fromY = Math.max(0, Math.round(peak.y - peak.widthY * nSigma));\n    var toY = Math.min(matrix.length - 1, Math.round(peak.y + peak.widthY * nSigma));\n\n    var squareSigmaX = peak.widthX * peak.widthX;\n    var squareSigmaY = peak.widthY * peak.widthY;\n    for (var j = fromY; j < toY; j++) {\n        for (var i = fromX; i < toX; i++) {\n            var exponent = Math.pow(peak.x - i, 2) / squareSigmaX +\n                Math.pow(peak.y - j, 2) / squareSigmaY;\n            var result = 10000 * peak.z * Math.exp(-exponent);\n            matrix[j][i] += result;\n        }\n    }\n}\n\n\nmodule.exports = simule2DNmrSpectrum;\n\n\n\n// WEBPACK FOOTER //\n// ./src/simulate2D.js","'use strict';\n\nconst Matrix = require('ml-matrix');\nconst SparseMatrix = require('ml-sparse-matrix');\nconst binarySearch = require('binary-search');\nconst sortAsc = require('num-sort').asc;\nconst newArray = require('new-array');\n\nconst getPauli = require('./pauli');\n\nconst smallValue = 1e-2;\n\nfunction simulate1d(spinSystem, options) {\n    var i, j;\n    const frequencyMHz = (options.frequency || 400);\n    const from = (options.from || 0) * frequencyMHz;\n    const to = (options.to || 10) * frequencyMHz;\n    const lineWidth = options.lineWidth || 1;\n    const nbPoints = options.nbPoints || 1024;\n    const maxClusterSize = options.maxClusterSize || 10;\n    const output = options.output || 'y';\n\n    const chemicalShifts = spinSystem.chemicalShifts.slice();\n    for (i = 0; i < chemicalShifts.length; i++) {\n        chemicalShifts[i] = chemicalShifts[i] * frequencyMHz;\n    }\n\n    let lineWidthPoints = (nbPoints * lineWidth / Math.abs(to - from)) / 2.355;\n    let lnPoints = lineWidthPoints * 20;\n\n    const gaussianLength = lnPoints | 0;\n    const gaussian = new Array(gaussianLength);\n    const b = lnPoints / 2;\n    const c = lineWidthPoints * lineWidthPoints * 2;\n    for (i = 0; i < gaussianLength; i++) {\n        gaussian[i] = 1e12 * Math.exp(-((i - b) * (i - b)) / c);\n    }\n\n    const result = new newArray(nbPoints, 0);\n\n    const multiplicity = spinSystem.multiplicity;\n    for (var h = 0; h < spinSystem.clusters.length; h++) {\n        const cluster = spinSystem.clusters[h];\n\n        var clusterFake = new Array(cluster.length);\n        for (i = 0; i < cluster.length; i++) {\n            clusterFake[i] = cluster[i] < 0 ? -cluster[i] - 1 : cluster[i];\n        }\n\n        var weight = 1;\n        var sumI = 0;\n        const frequencies = [];\n        const intensities = [];\n        if (cluster.length > maxClusterSize) {\n            //This is a single spin, but the cluster exceeds the maxClusterSize criteria\n            //we use the simple multiplicity algorithm\n            //Add the central peak. It will be split with every single J coupling.\n            var index = 0;\n            while (cluster[index++] < 0);\n            index = cluster[index - 1];\n            var currentSize, jc;\n            frequencies.push(-chemicalShifts[index]);\n            for (i = 0; i < cluster.length; i++) {\n                if (cluster[i] < 0) {\n                    jc = spinSystem.couplingConstants[index][clusterFake[i]] / 2;\n                    currentSize = frequencies.length;\n                    for (j = 0; j < currentSize; j++) {\n                        frequencies.push(frequencies[j] + jc);\n                        frequencies[j] -= jc;\n                    }\n                }\n            }\n\n            frequencies.sort(sortAsc);\n            sumI = frequencies.length;\n            weight = 1;\n\n            for (i = 0; i < sumI; i++) {\n                intensities.push(1);\n            }\n\n        } else {\n            const hamiltonian = getHamiltonian(\n                chemicalShifts,\n                spinSystem.couplingConstants,\n                multiplicity,\n                spinSystem.connectivity,\n                clusterFake\n            );\n\n            const hamSize = hamiltonian.rows;\n            const evd = new Matrix.DC.EVD(hamiltonian);\n            const V = evd.eigenvectorMatrix;\n            const diagB = evd.realEigenvalues;\n            const assignmentMatrix = new SparseMatrix(hamSize, hamSize);\n            const multLen = cluster.length;\n            weight = 0;\n            for (var n = 0; n < multLen; n++) {\n                const L = getPauli(multiplicity[clusterFake[n]]);\n\n                let temp = 1;\n                for (j = 0; j < n; j++) {\n                    temp *= multiplicity[clusterFake[j]];\n                }\n                const A = SparseMatrix.eye(temp);\n\n                temp = 1;\n                for (j = n + 1; j < multLen; j++) {\n                    temp *= multiplicity[clusterFake[j]];\n                }\n                const B = SparseMatrix.eye(temp);\n                const tempMat = A.kroneckerProduct(L.m).kroneckerProduct(B);\n                if (cluster[n] >= 0) {\n                    assignmentMatrix.add(tempMat.mul(cluster[n] + 1));\n                    weight++;\n                } else {\n                    assignmentMatrix.add(tempMat.mul(cluster[n]));\n                }\n            }\n\n            let rhoip = Matrix.zeros(hamSize, hamSize);\n            assignmentMatrix.forEachNonZero((i, j, v) => {\n                if (v > 0) {\n                    const row = V[j];\n                    for (var k = 0; k < row.length; k++) {\n                        if (row[k] !== 0) {\n                            rhoip.set(i, k, rhoip.get(i, k) + row[k]);\n                        }\n                    }\n                }\n                return v;\n            });\n\n            let rhoip2 = rhoip.clone();\n            assignmentMatrix.forEachNonZero((i, j, v) => {\n                if (v < 0) {\n                    const row = V[j];\n                    for (var k = 0; k < row.length; k++) {\n                        if (row[k] !== 0) {\n                            rhoip2.set(i, k, rhoip2.get(i, k) + row[k]);\n                        }\n                    }\n                }\n                return v;\n            });\n\n            const tV = V.transpose();\n            rhoip = tV.mmul(rhoip);\n            rhoip = new SparseMatrix(rhoip, {threshold: smallValue});\n            triuTimesAbs(rhoip, smallValue);\n            rhoip2 = tV.mmul(rhoip2);\n            rhoip2 = new SparseMatrix(rhoip2, {threshold: smallValue});\n            triuTimesAbs(rhoip2, smallValue);\n\n            rhoip2.forEachNonZero((i, j, v) => {\n                var val = rhoip.get(i, j);\n                val = Math.min(Math.abs(val), Math.abs(v));\n                val *= val;\n\n                sumI += val;\n                var valFreq = diagB[i] - diagB[j];\n                var insertIn = binarySearch(frequencies, valFreq, sortAsc);\n                if (insertIn < 0) {\n                    frequencies.splice(-1 - insertIn, 0, valFreq);\n                    intensities.splice(-1 - insertIn, 0, val);\n                } else {\n                    intensities[insertIn] += val;\n                }\n            });\n        }\n        const numFreq = frequencies.length;\n        if (numFreq > 0) {\n            weight = weight / sumI;\n            const diff = lineWidth / 32;\n            let valFreq = frequencies[0];\n            let inte = intensities[0];\n            let count = 1;\n            for (i = 1; i < numFreq; i++) {\n                if (Math.abs(frequencies[i] - valFreq / count) < diff) {\n                    inte += intensities[i];\n                    valFreq += frequencies[i];\n                    count++;\n                } else {\n                    addPeak(result, valFreq / count, inte * weight, from, to, nbPoints, gaussian);\n                    valFreq = frequencies[i];\n                    inte = intensities[i];\n                    count = 1;\n                }\n            }\n            addPeak(result, valFreq / count, inte * weight, from, to, nbPoints, gaussian);\n        }\n    }\n    if (output === 'xy') {\n        return {x: _getX(options.from, options.to, nbPoints), y: result};\n    }\n    if (output === 'y') {\n        return result;\n    }\n    throw new RangeError('wrong output option');\n}\n\nfunction addPeak(result, freq, height, from, to, nbPoints, gaussian) {\n    const center = (nbPoints * (-freq - from) / (to - from)) | 0;\n    const lnPoints = gaussian.length;\n    var index = 0;\n    var indexLorentz = 0;\n    for (var i = center - lnPoints / 2; i < center + lnPoints / 2; i++) {\n        index = i | 0;\n        if (i >= 0 && i < nbPoints) {\n            result[index] = result[index] + gaussian[indexLorentz] * height;\n        }\n        indexLorentz++;\n    }\n}\n\nfunction triuTimesAbs(A, val) {\n    A.forEachNonZero((i, j, v) => {\n        if (i > j) return 0;\n        if (Math.abs(v) <= val) return 0;\n        return v;\n    });\n}\n\nfunction getHamiltonian(chemicalShifts, couplingConstants, multiplicity, conMatrix, cluster) {\n    let hamSize = 1;\n    for (var i = 0; i < cluster.length; i++) {\n        hamSize *= multiplicity[cluster[i]];\n    }\n\n    const clusterHam = new SparseMatrix(hamSize, hamSize);\n\n    for (var pos = 0; pos < cluster.length; pos++) {\n        var n = cluster[pos];\n\n        const L = getPauli(multiplicity[n]);\n\n        let A1, B1;\n        let temp = 1;\n        for (let i = 0; i < pos; i++) {\n            temp *= multiplicity[cluster[i]];\n        }\n        A1 = SparseMatrix.eye(temp);\n\n        temp = 1;\n        for (let i = pos + 1; i < cluster.length; i++) {\n            temp *= multiplicity[cluster[i]];\n        }\n        B1 = SparseMatrix.eye(temp);\n\n        const alpha = chemicalShifts[n];\n        const kronProd = A1.kroneckerProduct(L.z).kroneckerProduct(B1);\n        clusterHam.add(kronProd.mul(alpha));\n\n        for (var pos2 = 0; pos2 < cluster.length; pos2++) {\n            const k = cluster[pos2];\n            if (conMatrix[n][k] === 1) {\n                const S = getPauli(multiplicity[k]);\n\n                let A2, B2;\n                let temp = 1;\n                for (let i = 0; i < pos2; i++) {\n                    temp *= multiplicity[cluster[i]];\n                }\n                A2 = SparseMatrix.eye(temp);\n\n                temp = 1;\n                for (let i = pos2 + 1; i < cluster.length; i++) {\n                    temp *= multiplicity[cluster[i]];\n                }\n                B2 = SparseMatrix.eye(temp);\n\n                const kron1 = A1.kroneckerProduct(L.x).kroneckerProduct(B1).mmul(A2.kroneckerProduct(S.x).kroneckerProduct(B2));\n                kron1.add(A1.kroneckerProduct(L.y).kroneckerProduct(B1).mul(-1).mmul(A2.kroneckerProduct(S.y).kroneckerProduct(B2)));\n                kron1.add(A1.kroneckerProduct(L.z).kroneckerProduct(B1).mmul(A2.kroneckerProduct(S.z).kroneckerProduct(B2)));\n\n                clusterHam.add(kron1.mul(couplingConstants[n][k] / 2));\n            }\n        }\n    }\n\n    return clusterHam;\n}\n\nfunction _getX(from, to, nbPoints) {\n    const x = new Array(nbPoints);\n    const dx = (to - from) / (nbPoints - 1);\n    for (var i = 0; i < nbPoints; i++) {\n        x[i] = from + i * dx;\n    }\n    return x;\n}\n\nmodule.exports = simulate1d;\n\n\n\n// WEBPACK FOOTER //\n// ./src/simulate1D.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nmrSimulation\"] = factory();\n\telse\n\t\troot[\"nmrSimulation\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 53);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1f39b7b8b21dcc6e594f","'use strict';\n\nrequire('./symbol-species');\nvar abstractMatrix = require('./abstractMatrix');\nvar util = require('./util');\n\nclass Matrix extends abstractMatrix(Array) {\n    constructor(nRows, nColumns) {\n        var i;\n        if (arguments.length === 1 && typeof nRows === 'number') {\n            return new Array(nRows);\n        }\n        if (Matrix.isMatrix(nRows)) {\n            return nRows.clone();\n        } else if (Number.isInteger(nRows) && nRows > 0) { // Create an empty matrix\n            super(nRows);\n            if (Number.isInteger(nColumns) && nColumns > 0) {\n                for (i = 0; i < nRows; i++) {\n                    this[i] = new Array(nColumns);\n                }\n            } else {\n                throw new TypeError('nColumns must be a positive integer');\n            }\n        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array\n            const matrix = nRows;\n            nRows = matrix.length;\n            nColumns = matrix[0].length;\n            if (typeof nColumns !== 'number' || nColumns === 0) {\n                throw new TypeError('Data must be a 2D array with at least one element');\n            }\n            super(nRows);\n            for (i = 0; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                }\n                this[i] = [].concat(matrix[i]);\n            }\n        } else {\n            throw new TypeError('First argument must be a positive number or an array');\n        }\n        this.rows = nRows;\n        this.columns = nColumns;\n        return this;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this[rowIndex][columnIndex] = value;\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this[rowIndex][columnIndex];\n    }\n\n    /**\n     * Creates an exact and independent copy of the matrix\n     * @return {Matrix}\n     */\n    clone() {\n        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);\n        for (var row = 0; row < this.rows; row++) {\n            for (var column = 0; column < this.columns; column++) {\n                newMatrix.set(row, column, this.get(row, column));\n            }\n        }\n        return newMatrix;\n    }\n\n    /**\n     * Removes a row from the given index\n     * @param {number} index - Row index\n     * @return {Matrix} this\n     */\n    removeRow(index) {\n        util.checkRowIndex(this, index);\n        if (this.rows === 1) {\n            throw new RangeError('A matrix cannot have less than one row');\n        }\n        this.splice(index, 1);\n        this.rows -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a row at the given index\n     * @param {number} [index = this.rows] - Row index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addRow(index, array) {\n        if (array === undefined) {\n            array = index;\n            index = this.rows;\n        }\n        util.checkRowIndex(this, index, true);\n        array = util.checkRowVector(this, array, true);\n        this.splice(index, 0, array);\n        this.rows += 1;\n        return this;\n    }\n\n    /**\n     * Removes a column from the given index\n     * @param {number} index - Column index\n     * @return {Matrix} this\n     */\n    removeColumn(index) {\n        util.checkColumnIndex(this, index);\n        if (this.columns === 1) {\n            throw new RangeError('A matrix cannot have less than one column');\n        }\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 1);\n        }\n        this.columns -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a column at the given index\n     * @param {number} [index = this.columns] - Column index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addColumn(index, array) {\n        if (typeof array === 'undefined') {\n            array = index;\n            index = this.columns;\n        }\n        util.checkColumnIndex(this, index, true);\n        array = util.checkColumnVector(this, array);\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 0, array[i]);\n        }\n        this.columns += 1;\n        return this;\n    }\n}\n\nexports.Matrix = Matrix;\nMatrix.abstractMatrix = abstractMatrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/matrix.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar abstractMatrix = require('../abstractMatrix');\nvar Matrix = require('../matrix');\n\nclass BaseView extends abstractMatrix() {\n    constructor(matrix, rows, columns) {\n        super();\n        this.matrix = matrix;\n        this.rows = rows;\n        this.columns = columns;\n    }\n\n    static get [Symbol.species]() {\n        return Matrix.Matrix;\n    }\n}\n\nmodule.exports = BaseView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/base.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar Matrix = require('./matrix');\n\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkRowIndex = function checkRowIndex(matrix, index, outer) {\n    var max = outer ? matrix.rows : matrix.rows - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Row index out of range');\n    }\n};\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkColumnIndex = function checkColumnIndex(matrix, index, outer) {\n    var max = outer ? matrix.columns : matrix.columns - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Column index out of range');\n    }\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkRowVector = function checkRowVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.columns) {\n        throw new RangeError('vector size must be the same as the number of columns');\n    }\n    return vector;\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkColumnVector = function checkColumnVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.rows) {\n        throw new RangeError('vector size must be the same as the number of rows');\n    }\n    return vector;\n};\n\nexports.checkIndices = function checkIndices(matrix, rowIndices, columnIndices) {\n    var rowOut = rowIndices.some(r => {\n        return r < 0 || r >= matrix.rows;\n\n    });\n\n    var columnOut = columnIndices.some(c => {\n        return c < 0 || c >= matrix.columns;\n    });\n\n    if (rowOut || columnOut) {\n        throw new RangeError('Indices are out of range');\n    }\n\n    if (typeof rowIndices !== 'object' || typeof columnIndices !== 'object') {\n        throw new TypeError('Unexpected type for row/column indices');\n    }\n    if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n    if (!Array.isArray(columnIndices)) rowIndices = Array.from(columnIndices);\n\n    return {\n        row: rowIndices,\n        column: columnIndices\n    };\n};\n\nexports.checkRange = function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n    if (arguments.length !== 5) throw new TypeError('Invalid argument type');\n    var notAllNumbers = Array.from(arguments).slice(1).some(function (arg) {\n        return typeof arg !== 'number';\n    });\n    if (notAllNumbers) throw new TypeError('Invalid argument type');\n    if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {\n        throw new RangeError('Submatrix indices are out of range');\n    }\n};\n\nexports.getRange = function getRange(from, to) {\n    var arr = new Array(to - from + 1);\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = from + i;\n    }\n    return arr;\n};\n\nexports.sumByRow = function sumByRow(matrix) {\n    var sum = Matrix.Matrix.zeros(matrix.rows, 1);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumByColumn = function sumByColumn(matrix) {\n    var sum = Matrix.Matrix.zeros(1, matrix.columns);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(0, j, sum.get(0, j) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumAll = function sumAll(matrix) {\n    var v = 0;\n    for (var i = 0; i < matrix.rows; i++) {\n        for (var j = 0; j < matrix.columns; j++) {\n            v += matrix.get(i, j);\n        }\n    }\n    return v;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/util.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nconst Heap = require('heap');\n\nfunction Cluster() {\n    this.children = [];\n    this.distance = -1;\n    this.index = [];\n}\n\n/**\n * Creates an array of values where maximum distance smaller than the threshold\n * @param {number} threshold\n * @return {Array <Cluster>}\n */\nCluster.prototype.cut = function (threshold) {\n    if (threshold < 0) throw new RangeError('Threshold too small');\n    var root = new Cluster();\n    root.children = this.children;\n    root.distance = this.distance;\n    root.index = this.index;\n    var list = [root];\n    var ans = [];\n    while (list.length > 0) {\n        var aux = list.shift();\n        if (threshold >= aux.distance) {\n            ans.push(aux);\n        } else {\n            list = list.concat(aux.children);\n        }\n    }\n    return ans;\n};\n\n/**\n * Merge the leaves in the minimum way to have 'minGroups' number of clusters\n * @param {number} minGroups - Them minimum number of children the first level of the tree should have\n * @return {Cluster}\n */\nCluster.prototype.group = function (minGroups) {\n    if (!Number.isInteger(minGroups) || minGroups < 1) throw new RangeError('Number of groups must be a positive integer');\n\n    const heap = new Heap(function (a, b) {\n        return b.distance - a.distance;\n    });\n\n    heap.push(this);\n\n    while (heap.size() < minGroups) {\n        var first = heap.pop();\n        if (first.children.length === 0) {\n            break;\n        }\n        first.children.forEach(child => heap.push(child));\n    }\n\n    var root = new Cluster();\n    root.children = heap.toArray();\n    root.distance = this.distance;\n\n    return root;\n};\n\n/**\n * Traverses the tree depth-first and provide callback to be called on each individual node\n * @param {function} cb - The callback to be called on each node encounter\n * @type {Cluster}\n */\nCluster.prototype.traverse = function (cb) {\n    function visit(root, callback) {\n        callback(root);\n        if (root.children) {\n            for (var i = root.children.length - 1; i >= 0; i--) {\n                visit(root.children[i], callback);\n            }\n        }\n    }\n    visit(this, cb);\n};\n\nmodule.exports = Cluster;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hclust/src/Cluster.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n// For use in the decomposition algorithms. With big matrices, access time is\n// too long on elements from array subclass\n// todo check when it is fixed in v8\n// http://jsperf.com/access-and-write-array-subclass\nexports.getEmpty2DArray = function (rows, columns) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n    }\n    return array;\n};\n\nexports.getFilled2DArray = function (rows, columns, value) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n        for (var j = 0; j < columns; j++) {\n            array[i][j] = value;\n        }\n    }\n    return array;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/util.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nmodule.exports = require('./matrix').Matrix;\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/index.js\n// module id = 5\n// module chunks = 0","module.exports = newArray\n\nfunction newArray (n, value) {\n  n = n || 0\n  var array = new Array(n)\n  for (var i = 0; i < n; i++) {\n    array[i] = value\n  }\n  return array\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/new-array/index.js\n// module id = 6\n// module chunks = 0","module.exports = function(haystack, needle, comparator, low, high) {\n  var mid, cmp;\n\n  if(low === undefined)\n    low = 0;\n\n  else {\n    low = low|0;\n    if(low < 0 || low >= haystack.length)\n      throw new RangeError(\"invalid lower bound\");\n  }\n\n  if(high === undefined)\n    high = haystack.length - 1;\n\n  else {\n    high = high|0;\n    if(high < low || high >= haystack.length)\n      throw new RangeError(\"invalid upper bound\");\n  }\n\n  while(low <= high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + (high - low >> 1);\n    cmp = +comparator(haystack[mid], needle, mid, haystack);\n\n    /* Too low. */\n    if(cmp < 0.0)\n      low  = mid + 1;\n\n    /* Too high. */\n    else if(cmp > 0.0)\n      high = mid - 1;\n\n    /* Key found. */\n    else\n      return mid;\n  }\n\n  /* Key not found. */\n  return ~low;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/binary-search/index.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nfunction squaredEuclidean(p, q) {\n    var d = 0;\n    for (var i = 0; i < p.length; i++) {\n        d += (p[i] - q[i]) * (p[i] - q[i]);\n    }\n    return d;\n}\n\nfunction euclidean(p, q) {\n    return Math.sqrt(squaredEuclidean(p, q));\n}\n\nmodule.exports = euclidean;\neuclidean.squared = squaredEuclidean;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-distance-euclidean/euclidean.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nconst Cluster = require('./Cluster');\nconst util = require('util');\n\nfunction ClusterLeaf(index) {\n    Cluster.call(this);\n    this.index = index;\n    this.distance = 0;\n    this.children = [];\n}\n\nutil.inherits(ClusterLeaf, Cluster);\n\nmodule.exports = ClusterLeaf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hclust/src/ClusterLeaf.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nmodule.exports = abstractMatrix;\n\nvar LuDecomposition = require('./dc/lu');\nvar SvDecomposition = require('./dc/svd');\nvar arrayUtils = require('ml-array-utils');\nvar util = require('./util');\nvar MatrixTransposeView = require('./views/transpose');\nvar MatrixRowView = require('./views/row');\nvar MatrixSubView = require('./views/sub');\nvar MatrixSelectionView = require('./views/selection');\nvar MatrixColumnView = require('./views/column');\nvar MatrixFlipRowView = require('./views/flipRow');\nvar MatrixFlipColumnView = require('./views/flipColumn');\n\nfunction abstractMatrix(superCtor) {\n    if (superCtor === undefined) superCtor = Object;\n\n    /**\n     * Real matrix\n     * @class Matrix\n     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,\n     * 2D array containing the data or Matrix instance to clone\n     * @param {number} [nColumns] - Number of columns of the new matrix\n     */\n    class Matrix extends superCtor {\n        static get [Symbol.species]() {\n            return this;\n        }\n\n        /**\n         * Constructs a Matrix with the chosen dimensions from a 1D array\n         * @param {number} newRows - Number of rows\n         * @param {number} newColumns - Number of columns\n         * @param {Array} newData - A 1D array containing data for the matrix\n         * @return {Matrix} - The new matrix\n         */\n        static from1DArray(newRows, newColumns, newData) {\n            var length = newRows * newColumns;\n            if (length !== newData.length) {\n                throw new RangeError('Data length does not match given dimensions');\n            }\n            var newMatrix = new this(newRows, newColumns);\n            for (var row = 0; row < newRows; row++) {\n                for (var column = 0; column < newColumns; column++) {\n                    newMatrix.set(row, column, newData[row * newColumns + column]);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Creates a row vector, a matrix with only one row.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static rowVector(newData) {\n            var vector = new this(1, newData.length);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(0, i, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates a column vector, a matrix with only one column.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static columnVector(newData) {\n            var vector = new this(newData.length, 1);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(i, 0, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static empty(rows, columns) {\n            return new this(rows, columns);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to zero.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static zeros(rows, columns) {\n            return this.empty(rows, columns).fill(0);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to one.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static ones(rows, columns) {\n            return this.empty(rows, columns).fill(1);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be randomly set.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static rand(rows, columns, rng) {\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    matrix.set(i, j, rng());\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be random integers.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {number} [maxValue=1000] - Maximum value\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static randInt(rows, columns, maxValue, rng) {\n            if (maxValue === undefined) maxValue = 1000;\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    var value = Math.floor(rng() * maxValue);\n                    matrix.set(i, j, value);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.\n         * @param {number} rows - Number of rows\n         * @param {number} [columns=rows] - Number of columns\n         * @param {number} [value=1] - Value to fill the diagonal with\n         * @return {Matrix} - The new identity matrix\n         */\n        static eye(rows, columns, value) {\n            if (columns === undefined) columns = rows;\n            if (value === undefined) value = 1;\n            var min = Math.min(rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, value);\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a diagonal matrix based on the given array.\n         * @param {Array} data - Array containing the data for the diagonal\n         * @param {number} [rows] - Number of rows (Default: data.length)\n         * @param {number} [columns] - Number of columns (Default: rows)\n         * @return {Matrix} - The new diagonal matrix\n         */\n        static diag(data, rows, columns) {\n            var l = data.length;\n            if (rows === undefined) rows = l;\n            if (columns === undefined) columns = rows;\n            var min = Math.min(l, rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, data[i]);\n            }\n            return matrix;\n        }\n\n        /**\n         * Returns a matrix whose elements are the minimum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static min(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Returns a matrix whose elements are the maximum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static max(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Check that the provided value is a Matrix and tries to instantiate one if not\n         * @param {*} value - The value to check\n         * @return {Matrix}\n         */\n        static checkMatrix(value) {\n            return Matrix.isMatrix(value) ? value : new this(value);\n        }\n\n        /**\n         * Returns true if the argument is a Matrix, false otherwise\n         * @param {*} value - The value to check\n         * @return {boolean}\n         */\n        static isMatrix(value) {\n            return (value != null) && (value.klass === 'Matrix');\n        }\n\n        /**\n         * @prop {number} size - The number of elements in the matrix.\n         */\n        get size() {\n            return this.rows * this.columns;\n        }\n\n        /**\n         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n         * @return {Matrix} this\n         */\n        apply(callback) {\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback must be a function');\n            }\n            var ii = this.rows;\n            var jj = this.columns;\n            for (var i = 0; i < ii; i++) {\n                for (var j = 0; j < jj; j++) {\n                    callback.call(this, i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new 1D array filled row by row with the matrix values\n         * @return {Array}\n         */\n        to1DArray() {\n            var array = new Array(this.size);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    array[i * this.columns + j] = this.get(i, j);\n                }\n            }\n            return array;\n        }\n\n        /**\n         * Returns a 2D array containing a copy of the data\n         * @return {Array}\n         */\n        to2DArray() {\n            var copy = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                copy[i] = new Array(this.columns);\n                for (var j = 0; j < this.columns; j++) {\n                    copy[i][j] = this.get(i, j);\n                }\n            }\n            return copy;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row\n         */\n        isRowVector() {\n            return this.rows === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one column\n         */\n        isColumnVector() {\n            return this.columns === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row or one column\n         */\n        isVector() {\n            return (this.rows === 1) || (this.columns === 1);\n        }\n\n        /**\n         * @return {boolean} true if the matrix has the same number of rows and columns\n         */\n        isSquare() {\n            return this.rows === this.columns;\n        }\n\n        /**\n         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n         */\n        isSymmetric() {\n            if (this.isSquare()) {\n                for (var i = 0; i < this.rows; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        if (this.get(i, j) !== this.get(j, i)) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @param {number} value - The new value for the element\n         * @return {Matrix} this\n         */\n        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars\n            throw new Error('set method is unimplemented');\n        }\n\n        /**\n         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @return {number}\n         */\n        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars\n            throw new Error('get method is unimplemented');\n        }\n\n        /**\n         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of\n         * rows of the matrix, and colRep times the number of columns of the matrix\n         * @param {number} rowRep - Number of times the rows should be repeated\n         * @param {number} colRep - Number of times the columns should be re\n         * @return {Matrix}\n         * @example\n         * var matrix = new Matrix([[1,2]]);\n         * matrix.repeat(2); // [[1,2],[1,2]]\n         */\n        repeat(rowRep, colRep) {\n            rowRep = rowRep || 1;\n            colRep = colRep || 1;\n            var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);\n            for (var i = 0; i < rowRep; i++) {\n                for (var j = 0; j < colRep; j++) {\n                    matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Fills the matrix with a given value. All elements will be set to this value.\n         * @param {number} value - New value\n         * @return {Matrix} this\n         */\n        fill(value) {\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, value);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Negates the matrix. All elements will be multiplied by (-1)\n         * @return {Matrix} this\n         */\n        neg() {\n            return this.mulS(-1);\n        }\n\n        /**\n         * Returns a new array from the given row index\n         * @param {number} index - Row index\n         * @return {Array}\n         */\n        getRow(index) {\n            util.checkRowIndex(this, index);\n            var row = new Array(this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                row[i] = this.get(index, i);\n            }\n            return row;\n        }\n\n        /**\n         * Returns a new row vector from the given row index\n         * @param {number} index - Row index\n         * @return {Matrix}\n         */\n        getRowVector(index) {\n            return this.constructor.rowVector(this.getRow(index));\n        }\n\n        /**\n         * Sets a row at the given index\n         * @param {number} index - Row index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setRow(index, array) {\n            util.checkRowIndex(this, index);\n            array = util.checkRowVector(this, array);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two rows\n         * @param {number} row1 - First row index\n         * @param {number} row2 - Second row index\n         * @return {Matrix} this\n         */\n        swapRows(row1, row2) {\n            util.checkRowIndex(this, row1);\n            util.checkRowIndex(this, row2);\n            for (var i = 0; i < this.columns; i++) {\n                var temp = this.get(row1, i);\n                this.set(row1, i, this.get(row2, i));\n                this.set(row2, i, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new array from the given column index\n         * @param {number} index - Column index\n         * @return {Array}\n         */\n        getColumn(index) {\n            util.checkColumnIndex(this, index);\n            var column = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                column[i] = this.get(i, index);\n            }\n            return column;\n        }\n\n        /**\n         * Returns a new column vector from the given column index\n         * @param {number} index - Column index\n         * @return {Matrix}\n         */\n        getColumnVector(index) {\n            return this.constructor.columnVector(this.getColumn(index));\n        }\n\n        /**\n         * Sets a column at the given index\n         * @param {number} index - Column index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setColumn(index, array) {\n            util.checkColumnIndex(this, index);\n            array = util.checkColumnVector(this, array);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two columns\n         * @param {number} column1 - First column index\n         * @param {number} column2 - Second column index\n         * @return {Matrix} this\n         */\n        swapColumns(column1, column2) {\n            util.checkColumnIndex(this, column1);\n            util.checkColumnIndex(this, column2);\n            for (var i = 0; i < this.rows; i++) {\n                var temp = this.get(i, column1);\n                this.set(i, column1, this.get(i, column2));\n                this.set(i, column2, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each row by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each column by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a row with a scalar\n         * @param {number} index - Row index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulRow(index, value) {\n            util.checkRowIndex(this, index);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, this.get(index, i) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a column with a scalar\n         * @param {number} index - Column index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulColumn(index, value) {\n            util.checkColumnIndex(this, index);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, this.get(i, index) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Returns the maximum value of the matrix\n         * @return {number}\n         */\n        max() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value\n         * @return {Array}\n         */\n        maxIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of the matrix\n         * @return {number}\n         */\n        min() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value\n         * @return {Array}\n         */\n        minIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        maxRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        maxRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        minRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        minRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        maxColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        maxColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        minColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        minColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns an array containing the diagonal values of the matrix\n         * @return {Array}\n         */\n        diag() {\n            var min = Math.min(this.rows, this.columns);\n            var diag = new Array(min);\n            for (var i = 0; i < min; i++) {\n                diag[i] = this.get(i, i);\n            }\n            return diag;\n        }\n\n        /**\n         * Returns the sum by the argument given, if no argument given,\n         * it returns the sum of all elements of the matrix.\n         * @param {string} by - sum by 'row' or 'column'.\n         * @return {Matrix|number}\n         */\n        sum(by) {\n            switch (by) {\n                case 'row':\n                    return util.sumByRow(this);\n                case 'column':\n                    return util.sumByColumn(this);\n                default:\n                    return util.sumAll(this);\n            }\n        }\n\n        /**\n         * Returns the mean of all elements of the matrix\n         * @return {number}\n         */\n        mean() {\n            return this.sum() / this.size;\n        }\n\n        /**\n         * Returns the product of all elements of the matrix\n         * @return {number}\n         */\n        prod() {\n            var prod = 1;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    prod *= this.get(i, j);\n                }\n            }\n            return prod;\n        }\n\n        /**\n         * Computes the cumulative sum of the matrix elements (in place, row by row)\n         * @return {Matrix} this\n         */\n        cumulativeSum() {\n            var sum = 0;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    sum += this.get(i, j);\n                    this.set(i, j, sum);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Computes the dot (scalar) product between the matrix and another\n         * @param {Matrix} vector2 vector\n         * @return {number}\n         */\n        dot(vector2) {\n            if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n            var vector1 = this.to1DArray();\n            if (vector1.length !== vector2.length) {\n                throw new RangeError('vectors do not have the same size');\n            }\n            var dot = 0;\n            for (var i = 0; i < vector1.length; i++) {\n                dot += vector1[i] * vector2[i];\n            }\n            return dot;\n        }\n\n        /**\n         * Returns the matrix product between this and other\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        mmul(other) {\n            other = this.constructor.checkMatrix(other);\n            if (this.columns !== other.rows) {\n                // eslint-disable-next-line no-console\n                console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n            }\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.columns;\n\n            var result = new this.constructor[Symbol.species](m, p);\n\n            var Bcolj = new Array(n);\n            for (var j = 0; j < p; j++) {\n                for (var k = 0; k < n; k++) {\n                    Bcolj[k] = other.get(k, j);\n                }\n\n                for (var i = 0; i < m; i++) {\n                    var s = 0;\n                    for (k = 0; k < n; k++) {\n                        s += this.get(i, k) * Bcolj[k];\n                    }\n\n                    result.set(i, j, s);\n                }\n            }\n            return result;\n        }\n\n        strassen2x2(other) {\n            var result = new this.constructor[Symbol.species](2, 2);\n            const a11 = this.get(0, 0);\n            const b11 = other.get(0, 0);\n            const a12 = this.get(0, 1);\n            const b12 = other.get(0, 1);\n            const a21 = this.get(1, 0);\n            const b21 = other.get(1, 0);\n            const a22 = this.get(1, 1);\n            const b22 = other.get(1, 1);\n\n            // Compute intermediate values.\n            const m1 = (a11 + a22) * (b11 + b22);\n            const m2 = (a21 + a22) * b11;\n            const m3 = a11 * (b12 - b22);\n            const m4 = a22 * (b21 - b11);\n            const m5 = (a11 + a12) * b22;\n            const m6 = (a21 - a11) * (b11 + b12);\n            const m7 = (a12 - a22) * (b21 + b22);\n\n            // Combine intermediate values into the output.\n            const c00 = m1 + m4 - m5 + m7;\n            const c01 = m3 + m5;\n            const c10 = m2 + m4;\n            const c11 = m1 - m2 + m3 + m6;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            return result;\n        }\n\n        strassen3x3(other) {\n            var result = new this.constructor[Symbol.species](3, 3);\n\n            const a00 = this.get(0, 0);\n            const a01 = this.get(0, 1);\n            const a02 = this.get(0, 2);\n            const a10 = this.get(1, 0);\n            const a11 = this.get(1, 1);\n            const a12 = this.get(1, 2);\n            const a20 = this.get(2, 0);\n            const a21 = this.get(2, 1);\n            const a22 = this.get(2, 2);\n\n            const b00 = other.get(0, 0);\n            const b01 = other.get(0, 1);\n            const b02 = other.get(0, 2);\n            const b10 = other.get(1, 0);\n            const b11 = other.get(1, 1);\n            const b12 = other.get(1, 2);\n            const b20 = other.get(2, 0);\n            const b21 = other.get(2, 1);\n            const b22 = other.get(2, 2);\n\n            const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n            const m2 = (a00 - a10) * (-b01 + b11);\n            const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n            const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n            const m5 = (a10 + a11) * (-b00 + b01);\n            const m6 = a00 * b00;\n            const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n            const m8 = (-a00 + a20) * (b02 - b12);\n            const m9 = (a20 + a21) * (-b00 + b02);\n            const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n            const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n            const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n            const m13 = (a02 - a22) * (b11 - b21);\n            const m14 = a02 * b20;\n            const m15 = (a21 + a22) * (-b20 + b21);\n            const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n            const m17 = (a02 - a12) * (b12 - b22);\n            const m18 = (a11 + a12) * (-b20 + b22);\n            const m19 = a01 * b10;\n            const m20 = a12 * b21;\n            const m21 = a10 * b02;\n            const m22 = a20 * b01;\n            const m23 = a22 * b22;\n\n            const c00 = m6 + m14 + m19;\n            const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n            const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n            const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n            const c11 = m2 + m4 + m5 + m6 + m20;\n            const c12 = m14 + m16 + m17 + m18 + m21;\n            const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n            const c21 = m12 + m13 + m14 + m15 + m22;\n            const c22 = m6 + m7 + m8 + m9 + m23;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(0, 2, c02);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            result.set(1, 2, c12);\n            result.set(2, 0, c20);\n            result.set(2, 1, c21);\n            result.set(2, 2, c22);\n            return result;\n        }\n\n        /**\n         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.\n         * @param {Matrix} y\n         * @return {Matrix}\n         */\n        mmulStrassen(y) {\n            var x = this.clone();\n            var r1 = x.rows;\n            var c1 = x.columns;\n            var r2 = y.rows;\n            var c2 = y.columns;\n            if (c1 !== r2) {\n                // eslint-disable-next-line no-console\n                console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);\n            }\n\n            // Put a matrix into the top left of a matrix of zeros.\n            // `rows` and `cols` are the dimensions of the output matrix.\n            function embed(mat, rows, cols) {\n                var r = mat.rows;\n                var c = mat.columns;\n                if ((r === rows) && (c === cols)) {\n                    return mat;\n                } else {\n                    var resultat = Matrix.zeros(rows, cols);\n                    resultat = resultat.setSubMatrix(mat, 0, 0);\n                    return resultat;\n                }\n            }\n\n\n            // Make sure both matrices are the same size.\n            // This is exclusively for simplicity:\n            // this algorithm can be implemented with matrices of different sizes.\n\n            var r = Math.max(r1, r2);\n            var c = Math.max(c1, c2);\n            x = embed(x, r, c);\n            y = embed(y, r, c);\n\n            // Our recursive multiplication function.\n            function blockMult(a, b, rows, cols) {\n                // For small matrices, resort to naive multiplication.\n                if (rows <= 512 || cols <= 512) {\n                    return a.mmul(b); // a is equivalent to this\n                }\n\n                // Apply dynamic padding.\n                if ((rows % 2 === 1) && (cols % 2 === 1)) {\n                    a = embed(a, rows + 1, cols + 1);\n                    b = embed(b, rows + 1, cols + 1);\n                } else if (rows % 2 === 1) {\n                    a = embed(a, rows + 1, cols);\n                    b = embed(b, rows + 1, cols);\n                } else if (cols % 2 === 1) {\n                    a = embed(a, rows, cols + 1);\n                    b = embed(b, rows, cols + 1);\n                }\n\n                var halfRows = parseInt(a.rows / 2);\n                var halfCols = parseInt(a.columns / 2);\n                // Subdivide input matrices.\n                var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n                var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n                var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n                var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n                var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n                var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n                var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n                var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n                // Compute intermediate values.\n                var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);\n                var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);\n                var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);\n                var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);\n                var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);\n                var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);\n                var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);\n\n                // Combine intermediate values into the output.\n                var c11 = Matrix.add(m1, m4);\n                c11.sub(m5);\n                c11.add(m7);\n                var c12 = Matrix.add(m3, m5);\n                var c21 = Matrix.add(m2, m4);\n                var c22 = Matrix.sub(m1, m2);\n                c22.add(m3);\n                c22.add(m6);\n\n                //Crop output to the desired size (undo dynamic padding).\n                var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);\n                resultat = resultat.setSubMatrix(c11, 0, 0);\n                resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n                resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n                resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n                return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n            }\n            return blockMult(x, y, r, c);\n        }\n\n        /**\n         * Returns a row-by-row scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The scaled matrix\n         */\n        scaleRows(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.rows; i++) {\n                var scaled = arrayUtils.scale(this.getRow(i), {min, max});\n                newMatrix.setRow(i, scaled);\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a new column-by-column scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The new scaled matrix\n         * @example\n         * var matrix = new Matrix([[1,2],[-1,0]]);\n         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]\n         */\n        scaleColumns(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                var scaled = arrayUtils.scale(this.getColumn(i), {\n                    min: min,\n                    max: max\n                });\n                newMatrix.setColumn(i, scaled);\n            }\n            return newMatrix;\n        }\n\n\n        /**\n         * Returns the Kronecker product (also known as tensor product) between this and other\n         * See https://en.wikipedia.org/wiki/Kronecker_product\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        kroneckerProduct(other) {\n            other = this.constructor.checkMatrix(other);\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.rows;\n            var q = other.columns;\n\n            var result = new this.constructor[Symbol.species](m * p, n * q);\n            for (var i = 0; i < m; i++) {\n                for (var j = 0; j < n; j++) {\n                    for (var k = 0; k < p; k++) {\n                        for (var l = 0; l < q; l++) {\n                            result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Transposes the matrix and returns a new one containing the result\n         * @return {Matrix}\n         */\n        transpose() {\n            var result = new this.constructor[Symbol.species](this.columns, this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    result.set(j, i, this.get(i, j));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Sorts the rows (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortRows(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.rows; i++) {\n                this.setRow(i, this.getRow(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Sorts the columns (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortColumns(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.columns; i++) {\n                this.setColumn(i, this.getColumn(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Returns a subset of the matrix\n         * @param {number} startRow - First row index\n         * @param {number} endRow - Last row index\n         * @param {number} startColumn - First column index\n         * @param {number} endColumn - Last column index\n         * @return {Matrix}\n         */\n        subMatrix(startRow, endRow, startColumn, endColumn) {\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);\n            for (var i = startRow; i <= endRow; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    newMatrix[i - startRow][j - startColumn] = this.get(i, j);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of row indices\n         * @param {Array} indices - Array containing the row indices\n         * @param {number} [startColumn = 0] - First column index\n         * @param {number} [endColumn = this.columns-1] - Last column index\n         * @return {Matrix}\n         */\n        subMatrixRow(indices, startColumn, endColumn) {\n            if (startColumn === undefined) startColumn = 0;\n            if (endColumn === undefined) endColumn = this.columns - 1;\n            if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.rows) {\n                        throw new RangeError('Row index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of column indices\n         * @param {Array} indices - Array containing the column indices\n         * @param {number} [startRow = 0] - First row index\n         * @param {number} [endRow = this.rows-1] - Last row index\n         * @return {Matrix}\n         */\n        subMatrixColumn(indices, startRow, endRow) {\n            if (startRow === undefined) startRow = 0;\n            if (endRow === undefined) endRow = this.rows - 1;\n            if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startRow; j <= endRow; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.columns) {\n                        throw new RangeError('Column index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Set a part of the matrix to the given sub-matrix\n         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.\n         * @param {number} startRow - The index of the first row to set\n         * @param {number} startColumn - The index of the first column to set\n         * @return {Matrix}\n         */\n        setSubMatrix(matrix, startRow, startColumn) {\n            matrix = this.constructor.checkMatrix(matrix);\n            var endRow = startRow + matrix.rows - 1;\n            var endColumn = startColumn + matrix.columns - 1;\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            for (var i = 0; i < matrix.rows; i++) {\n                for (var j = 0; j < matrix.columns; j++) {\n                    this[startRow + i][startColumn + j] = matrix.get(i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Return a new matrix based on a selection of rows and columns\n         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.\n         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.\n         * @return {Matrix} The new matrix\n         */\n        selection(rowIndices, columnIndices) {\n            var indices = util.checkIndices(this, rowIndices, columnIndices);\n            var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);\n            for (var i = 0; i < indices.row.length; i++) {\n                var rowIndex = indices.row[i];\n                for (var j = 0; j < indices.column.length; j++) {\n                    var columnIndex = indices.column[j];\n                    newMatrix[i][j] = this.get(rowIndex, columnIndex);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns the trace of the matrix (sum of the diagonal elements)\n         * @return {number}\n         */\n        trace() {\n            var min = Math.min(this.rows, this.columns);\n            var trace = 0;\n            for (var i = 0; i < min; i++) {\n                trace += this.get(i, i);\n            }\n            return trace;\n        }\n\n        /*\n         Matrix views\n         */\n\n        /**\n         * Returns a view of the transposition of the matrix\n         * @return {MatrixTransposeView}\n         */\n        transposeView() {\n            return new MatrixTransposeView(this);\n        }\n\n        /**\n         * Returns a view of the row vector with the given index\n         * @param {number} row - row index of the vector\n         * @return {MatrixRowView}\n         */\n        rowView(row) {\n            util.checkRowIndex(this, row);\n            return new MatrixRowView(this, row);\n        }\n\n        /**\n         * Returns a view of the column vector with the given index\n         * @param {number} column - column index of the vector\n         * @return {MatrixColumnView}\n         */\n        columnView(column) {\n            util.checkColumnIndex(this, column);\n            return new MatrixColumnView(this, column);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the row axis\n         * @return {MatrixFlipRowView}\n         */\n        flipRowView() {\n            return new MatrixFlipRowView(this);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the column axis\n         * @return {MatrixFlipColumnView}\n         */\n        flipColumnView() {\n            return new MatrixFlipColumnView(this);\n        }\n\n        /**\n         * Returns a view of a submatrix giving the index boundaries\n         * @param {number} startRow - first row index of the submatrix\n         * @param {number} endRow - last row index of the submatrix\n         * @param {number} startColumn - first column index of the submatrix\n         * @param {number} endColumn - last column index of the submatrix\n         * @return {MatrixSubView}\n         */\n        subMatrixView(startRow, endRow, startColumn, endColumn) {\n            return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);\n        }\n\n        /**\n         * Returns a view of the cross of the row indices and the column indices\n         * @example\n         * // resulting vector is [[2], [2]]\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])\n         * @param {Array<number>} rowIndices\n         * @param {Array<number>} columnIndices\n         * @return {MatrixSelectionView}\n         */\n        selectionView(rowIndices, columnIndices) {\n            return new MatrixSelectionView(this, rowIndices, columnIndices);\n        }\n\n\n        /**\n        * Calculates and returns the determinant of a matrix as a Number\n        * @example\n        *   new Matrix([[1,2,3], [4,5,6]]).det()\n        * @return {number}\n        */\n        det() {\n            if (this.isSquare()) {\n                var a, b, c, d;\n                if (this.columns === 2) {\n                    // 2 x 2 matrix\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(1, 0);\n                    d = this.get(1, 1);\n\n                    return a * d - (b * c);\n                } else if (this.columns === 3) {\n                    // 3 x 3 matrix\n                    var subMatrix0, subMatrix1, subMatrix2;\n                    subMatrix0 = this.selectionView([1, 2], [1, 2]);\n                    subMatrix1 = this.selectionView([1, 2], [0, 2]);\n                    subMatrix2 = this.selectionView([1, 2], [0, 1]);\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(0, 2);\n\n                    return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();\n                } else {\n                    // general purpose determinant using the LU decomposition\n                    return new LuDecomposition(this).determinant;\n                }\n\n            } else {\n                throw Error('Determinant can only be calculated for a square matrix.');\n            }\n        }\n\n        /**\n         * Returns inverse of a matrix if it exists or the pseudoinverse\n         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)\n         * @return {Matrix} the (pseudo)inverted matrix.\n         */\n        pseudoInverse(threshold) {\n            if (threshold === undefined) threshold = Number.EPSILON;\n            var svdSolution = new SvDecomposition(this, {autoTranspose: true});\n\n            var U = svdSolution.leftSingularVectors;\n            var V = svdSolution.rightSingularVectors;\n            var s = svdSolution.diagonal;\n\n            for (var i = 0; i < s.length; i++) {\n                if (Math.abs(s[i]) > threshold) {\n                    s[i] = 1.0 / s[i];\n                } else {\n                    s[i] = 0.0;\n                }\n            }\n\n            // convert list to diagonal\n            s = this.constructor[Symbol.species].diag(s);\n            return V.mmul(s.mmul(U.transposeView()));\n        }\n    }\n\n    Matrix.prototype.klass = 'Matrix';\n\n    /**\n     * @private\n     * Check that two matrices have the same dimensions\n     * @param {Matrix} matrix\n     * @param {Matrix} otherMatrix\n     */\n    function checkDimensions(matrix, otherMatrix) { // eslint-disable-line no-unused-vars\n        if (matrix.rows !== otherMatrix.rows ||\n            matrix.columns !== otherMatrix.columns) {\n            throw new RangeError('Matrices dimensions must be equal');\n        }\n    }\n\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n\n    /*\n     Synonyms\n     */\n\n    Matrix.random = Matrix.rand;\n    Matrix.diagonal = Matrix.diag;\n    Matrix.prototype.diagonal = Matrix.prototype.diag;\n    Matrix.identity = Matrix.eye;\n    Matrix.prototype.negate = Matrix.prototype.neg;\n    Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;\n    Matrix.prototype.determinant = Matrix.prototype.det;\n\n    /*\n     Add dynamically instance and static methods for mathematical operations\n     */\n\n    var inplaceOperator = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var inplaceOperatorScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceOperatorMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticOperator = `\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n`;\n\n    var inplaceMethod = `\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethod = `\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n`;\n\n    var inplaceMethodWithArgs = `\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethodWithArgs = `\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n`;\n\n\n    var inplaceMethodWithOneArgScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n`;\n    var inplaceMethodWithOneArgMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceMethodWithOneArg = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var staticMethodWithOneArg = staticMethodWithArgs;\n\n    var operators = [\n        // Arithmetic operators\n        ['+', 'add'],\n        ['-', 'sub', 'subtract'],\n        ['*', 'mul', 'multiply'],\n        ['/', 'div', 'divide'],\n        ['%', 'mod', 'modulus'],\n        // Bitwise operators\n        ['&', 'and'],\n        ['|', 'or'],\n        ['^', 'xor'],\n        ['<<', 'leftShift'],\n        ['>>', 'signPropagatingRightShift'],\n        ['>>>', 'rightShift', 'zeroFillRightShift']\n    ];\n\n    var i;\n\n    for (var operator of operators) {\n        var inplaceOp = eval(fillTemplateFunction(inplaceOperator, {name: operator[1], op: operator[0]}));\n        var inplaceOpS = eval(fillTemplateFunction(inplaceOperatorScalar, {name: operator[1] + 'S', op: operator[0]}));\n        var inplaceOpM = eval(fillTemplateFunction(inplaceOperatorMatrix, {name: operator[1] + 'M', op: operator[0]}));\n        var staticOp = eval(fillTemplateFunction(staticOperator, {name: operator[1]}));\n        for (i = 1; i < operator.length; i++) {\n            Matrix.prototype[operator[i]] = inplaceOp;\n            Matrix.prototype[operator[i] + 'S'] = inplaceOpS;\n            Matrix.prototype[operator[i] + 'M'] = inplaceOpM;\n            Matrix[operator[i]] = staticOp;\n        }\n    }\n\n    var methods = [\n        ['~', 'not']\n    ];\n\n    [\n        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',\n        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',\n        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\n    ].forEach(function (mathMethod) {\n        methods.push(['Math.' + mathMethod, mathMethod]);\n    });\n\n    for (var method of methods) {\n        var inplaceMeth = eval(fillTemplateFunction(inplaceMethod, {name: method[1], method: method[0]}));\n        var staticMeth = eval(fillTemplateFunction(staticMethod, {name: method[1]}));\n        for (i = 1; i < method.length; i++) {\n            Matrix.prototype[method[i]] = inplaceMeth;\n            Matrix[method[i]] = staticMeth;\n        }\n    }\n\n    var methodsWithArgs = [\n        ['Math.pow', 1, 'pow']\n    ];\n\n    for (var methodWithArg of methodsWithArgs) {\n        var args = 'arg0';\n        for (i = 1; i < methodWithArg[1]; i++) {\n            args += `, arg${i}`;\n        }\n        if (methodWithArg[1] !== 1) {\n            var inplaceMethWithArgs = eval(fillTemplateFunction(inplaceMethodWithArgs, {\n                name: methodWithArg[2],\n                method: methodWithArg[0],\n                args: args\n            }));\n            var staticMethWithArgs = eval(fillTemplateFunction(staticMethodWithArgs, {name: methodWithArg[2], args: args}));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;\n                Matrix[methodWithArg[i]] = staticMethWithArgs;\n            }\n        } else {\n            var tmplVar = {\n                name: methodWithArg[2],\n                args: args,\n                method: methodWithArg[0]\n            };\n            var inplaceMethod2 = eval(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));\n            var inplaceMethodS = eval(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));\n            var inplaceMethodM = eval(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));\n            var staticMethod2 = eval(fillTemplateFunction(staticMethodWithOneArg, tmplVar));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethod2;\n                Matrix.prototype[methodWithArg[i] + 'M'] = inplaceMethodM;\n                Matrix.prototype[methodWithArg[i] + 'S'] = inplaceMethodS;\n                Matrix[methodWithArg[i]] = staticMethod2;\n            }\n        }\n    }\n\n    function fillTemplateFunction(template, values) {\n        for (var value in values) {\n            template = template.replace(new RegExp('%' + value + '%', 'g'), values[value]);\n        }\n        return template;\n    }\n\n    return Matrix;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/abstractMatrix.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n\n    matrix = Matrix.Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare()) {\n            throw new Error('Matrix must be square');\n        }\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++) {\n            determinant *= data[j][j];\n        }\n        return determinant;\n    },\n    get lowerTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows) {\n            throw new Error('Invalid matrix dimensions');\n        }\n        if (this.isSingular()) {\n            throw new Error('LU matrix is singular');\n        }\n\n        var count = value.columns;\n        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n        var columns = lu.columns;\n        var i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/lu.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\nvar util = require('./util');\nvar hypotenuse = util.hypotenuse;\nvar getFilled2DArray = util.getFilled2DArray;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false) wantu = false;\n    if (options.computeRightSingularVectors === false) wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    var a;\n    if (m < n) {\n        if (!autoTranspose) {\n            a = value.clone();\n            // eslint-disable-next-line no-console\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = value.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    } else {\n        a = value.clone();\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = getFilled2DArray(m, nu, 0),\n        V = getFilled2DArray(n, n, 0),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0) {\n                    e[k] = 0 - e[k];\n                }\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n            // no default\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.U)) {\n            this.U = new Matrix.Matrix(this.U);\n        }\n        return this.U;\n    },\n    get rightSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.V)) {\n            this.V = new Matrix.Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n        var U = this.U;\n        var V = this.rightSingularVectors;\n\n        var VL = V.mmul(Ls),\n            vrows = V.rows,\n            urows = U.length,\n            VLU = Matrix.Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.Matrix.diag(value));\n    },\n    inverse: function () {\n        var V = this.V;\n        var e = this.threshold,\n            vrows = V.length,\n            vcols = V[0].length,\n            X = new Matrix.Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var U = this.U;\n\n        var urows = U.length,\n            ucols = U[0].length,\n            Y = new Matrix.Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/svd.js\n// module id = 12\n// module chunks = 0","const HashTable = require('ml-hash-table');\n\nclass SparseMatrix {\n    constructor(rows, columns, options = {}) {\n        if (rows instanceof SparseMatrix) { // clone\n            const other = rows;\n            this._init(other.rows, other.columns, other.elements.clone(), other.threshold);\n            return;\n        }\n\n        if (Array.isArray(rows)) {\n            const matrix = rows;\n            rows = matrix.length;\n            options = columns || {};\n            columns = matrix[0].length;\n            this._init(rows, columns, new HashTable(options), options.threshold);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    var value = matrix[i][j];\n                    if (this.threshold && Math.abs(value) < this.threshold) value = 0;\n                    if (value !== 0) {\n                        this.elements.set(i * columns + j, matrix[i][j]);\n                    }\n                }\n            }\n        } else {\n            this._init(rows, columns, new HashTable(options), options.threshold);\n        }\n    }\n\n    _init(rows, columns, elements, threshold) {\n        this.rows = rows;\n        this.columns = columns;\n        this.elements = elements;\n        this.threshold = threshold || 0;\n    }\n    \n    static eye(rows = 1, columns = rows) {\n        const min = Math.min(rows, columns);\n        const matrix = new SparseMatrix(rows, columns, {initialCapacity: min});\n        for (var i = 0; i < min; i++) {\n            matrix.set(i, i, 1);\n        }\n        return matrix;\n    }\n\n    clone() {\n        return new SparseMatrix(this);\n    }\n    \n    to2DArray() {\n        const copy = new Array(this.rows);\n        for (var i = 0; i < this.rows; i++) {\n            copy[i] = new Array(this.columns);\n            for (var j = 0; j < this.columns; j++) {\n                copy[i][j] = this.get(i, j);\n            }\n        }\n        return copy;\n    }\n\n    isSquare() {\n        return this.rows === this.columns;\n    }\n\n    isSymmetric() {\n        if (!this.isSquare()) return false;\n\n        var symmetric = true;\n        this.forEachNonZero((i, j, v) => {\n            if (this.get(j, i) !== v) {\n                symmetric = false;\n                return false;\n            }\n            return v;\n        });\n        return symmetric;\n    }\n\n    get cardinality() {\n        return this.elements.size;\n    }\n\n    get size() {\n        return this.rows * this.columns;\n    }\n\n    get(row, column) {\n        return this.elements.get(row * this.columns + column);\n    }\n\n    set(row, column, value) {\n        if (this.threshold && Math.abs(value) < this.threshold) value = 0;\n        if (value === 0) {\n            this.elements.remove(row * this.columns + column);\n        } else {\n            this.elements.set(row * this.columns + column, value);\n        }\n        return this;\n    }\n    \n    mmul(other) {\n        if (this.columns !== other.rows)\n            console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n        \n        const m = this.rows;\n        const p = other.columns;\n        \n        const result = new SparseMatrix(m, p);\n        this.forEachNonZero((i, j, v1) => {\n            other.forEachNonZero((k, l, v2) => {\n                if (j === k) {\n                    result.set(i, l, result.get(i, l) + v1 * v2);\n                }\n                return v2;\n            });\n            return v1;\n        });\n        return result;\n    }\n\n    kroneckerProduct(other) {\n        const m = this.rows;\n        const n = this.columns;\n        const p = other.rows;\n        const q = other.columns;\n\n        const result = new SparseMatrix(m * p, n * q, {\n            initialCapacity: this.cardinality * other.cardinality\n        });\n        this.forEachNonZero((i, j, v1) => {\n            other.forEachNonZero((k, l, v2) => {\n                result.set(p * i + k, q * j + l, v1 * v2);\n                return v2;\n            });\n            return v1;\n        });\n        return result;\n    }\n\n    forEachNonZero(callback) {\n        this.elements.forEachPair((key, value) => {\n            const i = (key / this.columns) | 0;\n            const j = key % this.columns;\n            let r = callback(i, j, value);\n            if (r === false) return false; // stop iteration\n            if (this.threshold && Math.abs(r) < this.threshold) r = 0;\n            if (r !== value) {\n                if (r === 0) {\n                    this.elements.remove(key, true);\n                } else {\n                    this.elements.set(key, r);\n                }\n            }\n            return true;\n        });\n        this.elements.maybeShrinkCapacity();\n        return this;\n    }\n\n    getNonZeros() {\n        const cardinality = this.cardinality;\n        const rows = new Array(cardinality);\n        const columns = new Array(cardinality);\n        const values = new Array(cardinality);\n        var idx = 0;\n        this.forEachNonZero((i, j, value) => {\n            rows[idx] = i;\n            columns[idx] = j;\n            values[idx] = value;\n            idx++;\n            return value;\n        });\n        return {rows, columns, values};\n    }\n\n    setThreshold(newThreshold) {\n        if (newThreshold !== 0 && newThreshold !== this.threshold) {\n            this.threshold = newThreshold;\n            this.forEachNonZero((i, j, v) => v);\n        }\n        return this;\n    }\n}\n\nSparseMatrix.prototype.klass = 'Matrix';\n\nSparseMatrix.identity = SparseMatrix.eye;\nSparseMatrix.prototype.tensorProduct = SparseMatrix.prototype.kroneckerProduct;\n\nmodule.exports = SparseMatrix;\n\n/*\n Add dynamically instance and static methods for mathematical operations\n */\n\nvar inplaceOperator = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\nvar inplaceOperatorScalar = `\n(function %name%S(value) {\n    this.forEachNonZero((i, j, v) => v %op% value);\n    return this;\n})\n`;\n\nvar inplaceOperatorMatrix = `\n(function %name%M(matrix) {\n    matrix.forEachNonZero((i, j, v) => {\n        this.set(i, j, this.get(i, j) %op% v);\n        return v;\n    });\n    return this;\n})\n`;\n\nvar staticOperator = `\n(function %name%(matrix, value) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%(value);\n})\n`;\n\nvar inplaceMethod = `\n(function %name%() {\n    this.forEachNonZero((i, j, v) => %method%(v));\n    return this;\n})\n`;\n\nvar staticMethod = `\n(function %name%(matrix) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%();\n})\n`;\n\nvar operators = [\n    // Arithmetic operators\n    ['+', 'add'],\n    ['-', 'sub', 'subtract'],\n    ['*', 'mul', 'multiply'],\n    ['/', 'div', 'divide'],\n    ['%', 'mod', 'modulus'],\n    // Bitwise operators\n    ['&', 'and'],\n    ['|', 'or'],\n    ['^', 'xor'],\n    ['<<', 'leftShift'],\n    ['>>', 'signPropagatingRightShift'],\n    ['>>>', 'rightShift', 'zeroFillRightShift']\n];\n\nfor (var operator of operators) {\n    for (var i = 1; i < operator.length; i++) {\n        SparseMatrix.prototype[operator[i]] = eval(fillTemplateFunction(inplaceOperator, {name: operator[i], op: operator[0]}));\n        SparseMatrix.prototype[operator[i] + 'S'] = eval(fillTemplateFunction(inplaceOperatorScalar, {name: operator[i] + 'S', op: operator[0]}));\n        SparseMatrix.prototype[operator[i] + 'M'] = eval(fillTemplateFunction(inplaceOperatorMatrix, {name: operator[i] + 'M', op: operator[0]}));\n\n        SparseMatrix[operator[i]] = eval(fillTemplateFunction(staticOperator, {name: operator[i]}));\n    }\n}\n\nvar methods = [\n    ['~', 'not']\n];\n\n[\n    'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',\n    'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',\n    'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\n].forEach(function (mathMethod) {\n    methods.push(['Math.' + mathMethod, mathMethod]);\n});\n\nfor (var method of methods) {\n    for (var i = 1; i < method.length; i++) {\n        SparseMatrix.prototype[method[i]] = eval(fillTemplateFunction(inplaceMethod, {name: method[i], method: method[0]}));\n        SparseMatrix[method[i]] = eval(fillTemplateFunction(staticMethod, {name: method[i]}));\n    }\n}\n\nfunction fillTemplateFunction(template, values) {\n    for (var i in values) {\n        template = template.replace(new RegExp('%' + i + '%', 'g'), values[i]);\n    }\n    return template;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-sparse-matrix/src/SparseMatrix.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/array.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/index.js\n// module id = 15\n// module chunks = 0","'use strict';\nvar numberIsNan = require('number-is-nan');\n\nfunction assertNum(x) {\n\tif (typeof x !== 'number' || numberIsNan(x)) {\n\t\tthrow new TypeError('Expected a number');\n\t}\n}\n\nexports.asc = function (a, b) {\n\tassertNum(a);\n\tassertNum(b);\n\treturn a - b;\n};\n\nexports.desc = function (a, b) {\n\tassertNum(a);\n\tassertNum(b);\n\treturn b - a;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/num-sort/index.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nconst Matrix = require('ml-matrix');\nconst newArray = require('new-array');\nconst simpleClustering = require('ml-simple-clustering');\nconst hlClust = require('ml-hclust');\n\nclass SpinSystem {\n    constructor(chemicalShifts, couplingConstants, multiplicity) {\n        this.chemicalShifts = chemicalShifts;\n        this.couplingConstants = couplingConstants;\n        this.multiplicity = multiplicity;\n        this.nSpins = chemicalShifts.length;\n        this._initConnectivity();\n        this._initClusters();\n    }\n\n    static fromSpinusPrediction(result) {\n        var lines = result.split('\\n');\n        var nspins = lines.length - 1;\n        var cs = new Array(nspins);\n        var integrals = new Array(nspins);\n        var ids = {};\n        var jc = Matrix.zeros(nspins, nspins);\n        for (let i = 0; i < nspins; i++) {\n            var tokens = lines[i].split('\\t');\n            cs[i] = +tokens[2];\n            ids[tokens[0] - 1] = i;\n            integrals[i] = +tokens[5];//Is it always 1??\n        }\n        for (let i = 0; i < nspins; i++) {\n            tokens = lines[i].split('\\t');\n            var nCoup = (tokens.length - 4) / 3;\n            for (j = 0; j < nCoup; j++) {\n                var withID = tokens[4 + 3 * j] - 1;\n                var idx = ids[withID];\n                jc[i][idx] = +tokens[6 + 3 * j];\n            }\n        }\n\n        for (var j = 0; j < nspins; j++) {\n            for (var i = j; i < nspins; i++) {\n                jc[j][i] = jc[i][j];\n            }\n        }\n        return new SpinSystem(cs, jc, newArray(nspins, 2));\n    }\n\n    static fromPrediction(input) {\n        let predictions = SpinSystem.ungroupAtoms(input);\n        const nSpins = predictions.length;\n        const cs = new Array(nSpins);\n        const jc = Matrix.zeros(nSpins, nSpins);\n        const multiplicity = new Array(nSpins);\n        const ids = {};\n        var i, k, j;\n        for (i = 0; i < nSpins; i++) {\n            cs[i] = predictions[i].delta;\n            ids[predictions[i].atomIDs[0]] = i;\n        }\n        for (i = 0; i < nSpins; i++) {\n            cs[i] = predictions[i].delta;\n            j = predictions[i].j;\n            for (k = 0; k < j.length; k++) {\n                //console.log(ids[result[i].atomIDs[0]],ids[j[k].assignment]);\n                jc[ids[predictions[i].atomIDs[0]]][ids[j[k].assignment]] = j[k].coupling;\n                jc[ids[j[k].assignment]][ids[predictions[i].atomIDs[0]]] = j[k].coupling;\n            }\n            multiplicity[i] = predictions[i].integral + 1;\n        }\n\n        return new SpinSystem(cs, jc, multiplicity);\n    }\n\n\n    static ungroupAtoms(prediction) {\n        let result = [];\n        prediction.forEach(pred => {\n            let atomIDs = pred.atomIDs;\n            for (let i = 0; i < atomIDs.length; i++) {\n                let tempPred = JSON.parse(JSON.stringify(pred));\n                tempPred.atomIDs = [atomIDs[i]];\n                tempPred.integral = 1;\n                result.push(tempPred);\n            }\n        });\n\n        return result;\n    }\n\n\n    _initClusters() {\n        this.clusters = simpleClustering(this.connectivity, {out: 'indexes'});\n    }\n\n    _initConnectivity() {\n        const couplings = this.couplingConstants;\n        const connectivity = Matrix.ones(couplings.length, couplings.length);\n        for (var i = 0; i < couplings.length; i++) {\n            for (var j = i; j < couplings[i].length; j++) {\n                if (couplings[i][j] === 0) {\n                    connectivity[i][j] = 0;\n                    connectivity[j][i] = 0;\n                }\n            }\n        }\n        this.connectivity = connectivity;\n    }\n\n\n    _calculateBetas(J, frequency) {\n        var betas = Matrix.zeros(J.length, J.length);\n        //Before clustering, we must add hidden J, we could use molecular information if available\n        var i, j;\n        for (i = 0; i < J.rows; i++) {\n            for (j = i; j < J.columns; j++) {\n                if ((this.chemicalShifts[i] - this.chemicalShifts[j]) !== 0) {\n                    betas[i][j] = 1 - Math.abs(J[i][j] / ((this.chemicalShifts[i] - this.chemicalShifts[j]) * frequency));\n                    betas[j][i] = betas[i][j];\n                } else if (!(i === j || J[i][j] !== 0)) {\n                    betas[i][j] = 1;\n                    betas[j][i] = 1;\n                }\n            }\n        }\n        return betas;\n    }\n\n    ensureClusterSize(options) {\n        var betas = this._calculateBetas(this.couplingConstants, options.frequency || 400);\n        var cluster = hlClust.agnes(betas, {isDistanceMatrix: true});\n        var list = [];\n        this._splitCluster(cluster, list, options.maxClusterSize || 8, false);\n        var clusters = this._mergeClusters(list);\n        this.nClusters = clusters.length;\n        //console.log(clusters);\n        this.clusters = new Array(clusters.length);\n        //System.out.println(this.conmatrix);\n        for (var j = 0; j < this.nClusters; j++) {\n            this.clusters[j] = [];\n            for (var i = 0; i < this.nSpins; i++) {\n                if (clusters[j][i] !== 0) {\n                    if (clusters[j][i] < 0) {\n                        this.clusters[j].push(-(i + 1));\n                    } else {\n                        this.clusters[j].push(i);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Recursively split the clusters until the maxClusterSize criteria has been ensured.\n     * @param cluster\n     * @param clusterList\n     */\n    _splitCluster(cluster, clusterList, maxClusterSize, force) {\n        if (!force && cluster.index.length <= maxClusterSize) {\n            clusterList.push(this._getMembers(cluster));\n        } else {\n            for (var child of cluster.children) {\n                if (!isNaN(child.index) || child.index.length <= maxClusterSize) {\n                    var members = this._getMembers(child);\n                    //Add the neighbors that shares at least 1 coupling with the given cluster\n                    var count = 0;\n                    for (var i = 0; i < this.nSpins; i++) {\n                        if (members[i] === 1) {\n                            count++;\n                            for (var j = 0; j < this.nSpins; j++) {\n                                if (this.connectivity[i][j] === 1 && members[j] === 0) {\n                                    members[j] = -1;\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n\n                    if (count <= maxClusterSize) {\n                        clusterList.push(members);\n                    } else {\n                        if (isNaN(child.index)) {\n                            this._splitCluster(child, clusterList, maxClusterSize, true);\n                        } else {\n                            //We have to threat this spin alone and use the resurrection algorithm instead of the simulation\n                            members[child.index] = 2;\n                            clusterList.push(members);\n                        }\n                    }\n                } else {\n                    this._splitCluster(child, clusterList, maxClusterSize, false);\n                }\n            }\n        }\n    }\n    /**\n     * Recursively gets the cluster members\n     * @param cluster\n     * @param members\n     */\n\n    _getMembers(cluster) {\n        var members = new Array(this.nSpins);\n        for (var i = 0; i < this.nSpins; i++) {\n            members[i] = 0;\n        }\n        if (!isNaN(cluster.index)) {\n            members[cluster.index * 1] = 1;\n        } else {\n            for (var index of cluster.index) {\n                members[index.index * 1] = 1;\n            }\n        }\n        return members;\n    }\n\n    _mergeClusters(list) {\n        var nElements = 0;\n        var clusterA, clusterB, i, j, index, common, count;\n        for (i = list.length - 1; i >= 0; i--) {\n            clusterA = list[i];\n            nElements = clusterA.length;\n            index = 0;\n\n            //Is it a candidate to be merged?\n            while (index < nElements && clusterA[index++] !== -1);\n\n            if (index < nElements) {\n                for (j = list.length - 1; j >= i + 1; j--) {\n                    clusterB = list[j];\n                    //Do they have common elements?\n                    index = 0;\n                    common = 0;\n                    count = 0;\n                    while (index < nElements) {\n                        if (clusterA[index] * clusterB[index] === -1) {\n                            common++;\n                        }\n                        if (clusterA[index] !== 0 || clusterB[index] !== 0) {\n                            count++;\n                        }\n                        index++;\n                    }\n\n                    if (common > 0 && count <= this.maxClusterSize) {\n                        //Then we can merge those 2 clusters\n                        index = 0;\n                        while (index < nElements) {\n                            if (clusterB[index] === 1) {\n                                clusterA[index] = 1;\n                            } else {\n                                if (clusterB[index] === -1 && clusterA[index] !== 1) {\n                                    clusterA[index] = -1;\n                                }\n                            }\n                            index++;\n                        }\n                        //list.remove(clusterB);\n                        list.splice(j, 1);\n                        j++;\n                    }\n                }\n            }\n        }\n\n        return list;\n    }\n}\n\nmodule.exports = SpinSystem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/SpinSystem.js","'use strict';\n\nconst SparseMatrix = require('ml-sparse-matrix');\n\nfunction createPauli(mult) {\n    const spin = (mult - 1) / 2;\n    const prjs = new Array(mult);\n    const temp = new Array(mult);\n    for (var i = 0; i < mult; i++) {\n        prjs[i] = (mult - 1) - i - spin;\n        temp[i] = Math.sqrt(spin * (spin + 1) - prjs[i] * (prjs[i] + 1));\n    }\n    const p = diag(temp, 1, mult, mult);\n    for (i = 0; i < mult; i++) {\n        temp[i] = Math.sqrt(spin * (spin + 1) - prjs[i] * (prjs[i] - 1));\n    }\n    const m = diag(temp, -1, mult, mult);\n    const x = p.clone().add(m).mul(0.5);\n    const y = m.clone().mul(-1).add(p).mul(-0.5);\n    const z = diag(prjs, 0, mult, mult);\n    return {x, y, z, m, p};\n}\n\nfunction diag(A, d, n, m) {\n    const diag = new SparseMatrix(n, m, {initialCapacity: 20});\n    for (var i = 0; i < A.length; i++) {\n        if ((i - d) >= 0 && (i - d) < n && i < m) {\n            diag.set(i - d, i, A[i]);\n        }\n    }\n    return diag;\n}\n\nconst pauli2 = createPauli(2);\n\nfunction getPauli(mult) {\n    if (mult === 2) return pauli2;\n    else return createPauli(mult);\n}\n\nmodule.exports = getPauli;\n\n\n\n// WEBPACK FOOTER //\n// ./src/pauli.js","module.exports = require('./lib/heap');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/heap/index.js\n// module id = 21\n// module chunks = 0","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/heap/lib/heap.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nconst Stat = require('ml-stat').array;\n/**\n * Function that returns an array of points given 1D array as follows:\n *\n * [x1, y1, .. , x2, y2, ..]\n *\n * And receive the number of dimensions of each point.\n * @param array\n * @param dimensions\n * @returns {Array} - Array of points.\n */\nfunction coordArrayToPoints(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var length = array.length / dimensions;\n    var pointsArr = new Array(length);\n\n    var k = 0;\n    for(var i = 0; i < array.length; i += dimensions) {\n        var point = new Array(dimensions);\n        for(var j = 0; j < dimensions; ++j) {\n            point[j] = array[i + j];\n        }\n\n        pointsArr[k] = point;\n        k++;\n    }\n\n    return pointsArr;\n}\n\n\n/**\n * Function that given an array as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * Returns an array as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * And receives the number of dimensions of each coordinate.\n * @param array\n * @param dimensions\n * @returns {Array} - Matrix of coordinates\n */\nfunction coordArrayToCoordMatrix(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var coordinatesArray = new Array(dimensions);\n    var points = array.length / dimensions;\n    for (var i = 0; i < coordinatesArray.length; i++) {\n        coordinatesArray[i] = new Array(points);\n    }\n\n    for(i = 0; i < array.length; i += dimensions) {\n        for(var j = 0; j < dimensions; ++j) {\n            var currentPoint = Math.floor(i / dimensions);\n            coordinatesArray[j][currentPoint] = array[i + j];\n        }\n    }\n\n    return coordinatesArray;\n}\n\n/**\n * Function that receives a coordinate matrix as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * Returns an array of coordinates as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param coordMatrix\n * @returns {Array}\n */\nfunction coordMatrixToCoordArray(coordMatrix) {\n    var coodinatesArray = new Array(coordMatrix.length * coordMatrix[0].length);\n    var k = 0;\n    for(var i = 0; i < coordMatrix[0].length; ++i) {\n        for(var j = 0; j < coordMatrix.length; ++j) {\n            coodinatesArray[k] = coordMatrix[j][i];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Tranpose a matrix, this method is for coordMatrixToPoints and\n * pointsToCoordMatrix, that because only transposing the matrix\n * you can change your representation.\n *\n * @param matrix\n * @returns {Array}\n */\nfunction transpose(matrix) {\n    var resultMatrix = new Array(matrix[0].length);\n    for(var i = 0; i < resultMatrix.length; ++i) {\n        resultMatrix[i] = new Array(matrix.length);\n    }\n\n    for (i = 0; i < matrix.length; ++i) {\n        for(var j = 0; j < matrix[0].length; ++j) {\n            resultMatrix[j][i] = matrix[i][j];\n        }\n    }\n\n    return resultMatrix;\n}\n\n/**\n * Function that transform an array of points into a coordinates array\n * as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param points\n * @returns {Array}\n */\nfunction pointsToCoordArray(points) {\n    var coodinatesArray = new Array(points.length * points[0].length);\n    var k = 0;\n    for(var i = 0; i < points.length; ++i) {\n        for(var j = 0; j < points[0].length; ++j) {\n            coodinatesArray[k] = points[i][j];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Apply the dot product between the smaller vector and a subsets of the\n * largest one.\n *\n * @param firstVector\n * @param secondVector\n * @returns {Array} each dot product of size of the difference between the\n *                  larger and the smallest one.\n */\nfunction applyDotProduct(firstVector, secondVector) {\n    var largestVector, smallestVector;\n    if(firstVector.length <= secondVector.length) {\n        smallestVector = firstVector;\n        largestVector = secondVector;\n    } else {\n        smallestVector = secondVector;\n        largestVector = firstVector;\n    }\n\n    var difference = largestVector.length - smallestVector.length + 1;\n    var dotProductApplied = new Array(difference);\n\n    for (var i = 0; i < difference; ++i) {\n        var sum = 0;\n        for (var j = 0; j < smallestVector.length; ++j) {\n            sum += smallestVector[j] * largestVector[i + j];\n        }\n        dotProductApplied[i] = sum;\n    }\n\n    return dotProductApplied;\n}\n/**\n * To scale the input array between the specified min and max values. The operation is performed inplace\n * if the options.inplace is specified. If only one of the min or max parameters is specified, then the scaling\n * will multiply the input array by min/min(input) or max/max(input)\n * @param input\n * @param options\n * @returns {*}\n */\nfunction scale(input, options){\n    var y;\n    if(options.inPlace){\n        y = input;\n    }\n    else{\n        y = new Array(input.length);\n    }\n    const max = options.max;\n    const min = options.min;\n    if(typeof max === \"number\"){\n        if(typeof min === \"number\"){\n            var minMax = Stat.minMax(input);\n            var factor = (max - min)/(minMax.max-minMax.min);\n            for(var i=0;i< y.length;i++){\n                y[i]=(input[i]-minMax.min)*factor+min;\n            }\n        }\n        else{\n            var currentMin = Stat.max(input);\n            var factor = max/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    else{\n        if(typeof min === \"number\"){\n            var currentMin = Stat.min(input);\n            var factor = min/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    return y;\n}\n\nmodule.exports = {\n    coordArrayToPoints: coordArrayToPoints,\n    coordArrayToCoordMatrix: coordArrayToCoordMatrix,\n    coordMatrixToCoordArray: coordMatrixToCoordArray,\n    coordMatrixToPoints: transpose,\n    pointsToCoordArray: pointsToCoordArray,\n    pointsToCoordMatrix: transpose,\n    applyDotProduct: applyDotProduct,\n    scale:scale\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/ArrayUtils.js\n// module id = 23\n// module chunks = 0","module.exports = exports = require('./ArrayUtils');\n\n\nexports.getEquallySpacedData = require('./getEquallySpaced').getEquallySpacedData;\nexports.SNV = require('./snv').SNV;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/index.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nexports.SNV = SNV;\nvar Stat = require('ml-stat').array;\n\n/**\n * Function that applies the standard normal variate (SNV) to an array of values.\n *\n * @param data - Array of values.\n * @returns {Array} - applied the SNV.\n */\nfunction SNV(data) {\n    var mean = Stat.mean(data);\n    var std = Stat.standardDeviation(data);\n    var result = data.slice();\n    for (var i = 0; i < data.length; i++) {\n        result[i] = (result[i] - mean) / std;\n    }\n    return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/snv.js\n// module id = 26\n// module chunks = 0","'use strict';\n\n\n/**\n * Computes a distance/similarity matrix given an array of data and a distance/similarity function.\n * @param {Array} data An array of data\n * @param {function} distanceFn  A function that accepts two arguments and computes a distance/similarity between them\n * @return {Array<Array>} The similarity matrix. The similarity matrix is square and has a size equal to the length of\n * the data array\n */\nfunction distanceMatrix(data, distanceFn) {\n    const length = data.length;\n    let result = Array.from({length}).map(() => Array.from({length}));\n\n    // Compute upper distance matrix\n    for (let i = 0; i < length; i++) {\n        for (let j = 0; j <= i; j++) {\n            result[i][j] = distanceFn(data[i], data[j]);\n        }\n    }\n\n    // Copy to lower distance matrix\n    for (let i = 0; i < length; i++) {\n        for (let j = i + 1; j < length; j++) {\n            result[i][j] = result[j][i];\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = distanceMatrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-distance-matrix/src/index.js\n// module id = 27\n// module chunks = 0","'use strict';\n\nconst newArray = require('new-array');\n\nconst primeFinder = require('./primeFinder');\nconst nextPrime = primeFinder.nextPrime;\nconst largestPrime = primeFinder.largestPrime;\n\nconst FREE = 0;\nconst FULL = 1;\nconst REMOVED = 2;\n\nconst defaultInitialCapacity = 150;\nconst defaultMinLoadFactor = 1 / 6;\nconst defaultMaxLoadFactor = 2 / 3;\n\nclass HashTable {\n    constructor(options = {}) {\n        if (options instanceof HashTable) {\n            this.table = options.table.slice();\n            this.values = options.values.slice();\n            this.state = options.state.slice();\n            this.minLoadFactor = options.minLoadFactor;\n            this.maxLoadFactor = options.maxLoadFactor;\n            this.distinct = options.distinct;\n            this.freeEntries = options.freeEntries;\n            this.lowWaterMark = options.lowWaterMark;\n            this.highWaterMark = options.maxLoadFactor;\n            return;\n        }\n\n        const initialCapacity = options.initialCapacity === undefined ? defaultInitialCapacity : options.initialCapacity;\n        if (initialCapacity < 0) {\n            throw new RangeError(`initial capacity must not be less than zero: ${initialCapacity}`);\n        }\n\n        const minLoadFactor = options.minLoadFactor === undefined ? defaultMinLoadFactor : options.minLoadFactor;\n        const maxLoadFactor = options.maxLoadFactor === undefined ? defaultMaxLoadFactor : options.maxLoadFactor;\n        if (minLoadFactor < 0 || minLoadFactor >= 1) {\n            throw new RangeError(`invalid minLoadFactor: ${minLoadFactor}`);\n        }\n        if (maxLoadFactor <= 0 || maxLoadFactor >= 1) {\n            throw new RangeError(`invalid maxLoadFactor: ${maxLoadFactor}`);\n        }\n        if (minLoadFactor >= maxLoadFactor) {\n            throw new RangeError(`minLoadFactor (${minLoadFactor}) must be smaller than maxLoadFactor (${maxLoadFactor})`);\n        }\n\n        let capacity = initialCapacity;\n        // User wants to put at least capacity elements. We need to choose the size based on the maxLoadFactor to\n        // avoid the need to rehash before this capacity is reached.\n        // actualCapacity * maxLoadFactor >= capacity\n        capacity = (capacity / maxLoadFactor) | 0;\n        capacity = nextPrime(capacity);\n        if (capacity === 0) capacity = 1;\n\n        this.table = newArray(capacity, 0);\n        this.values = newArray(capacity, 0);\n        this.state = newArray(capacity, 0);\n\n        this.minLoadFactor = minLoadFactor;\n        if (capacity === largestPrime) {\n            this.maxLoadFactor = 1;\n        } else {\n            this.maxLoadFactor = maxLoadFactor;\n        }\n\n        this.distinct = 0;\n        this.freeEntries = capacity;\n\n        this.lowWaterMark = 0;\n        this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);\n    }\n\n    clone() {\n        return new HashTable(this);\n    }\n\n    get size() {\n        return this.distinct;\n    }\n\n    get(key) {\n        const i = this.indexOfKey(key);\n        if (i < 0) return 0;\n        return this.values[i];\n    }\n\n    set(key, value) {\n        let i = this.indexOfInsertion(key);\n        if (i < 0) {\n            i = -i - 1;\n            this.values[i] = value;\n            return false;\n        }\n\n        if (this.distinct > this.highWaterMark) {\n            const newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);\n            this.rehash(newCapacity);\n            return this.set(key, value);\n        }\n\n        this.table[i] = key;\n        this.values[i] = value;\n        if (this.state[i] === FREE) this.freeEntries--;\n        this.state[i] = FULL;\n        this.distinct++;\n\n        if (this.freeEntries < 1) {\n            const newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);\n            this.rehash(newCapacity);\n        }\n\n        return true;\n    }\n    \n    remove(key, noRehash) {\n        const i = this.indexOfKey(key);\n        if (i < 0) return false;\n\n        this.state[i] = REMOVED;\n        this.distinct--;\n\n        if (!noRehash) this.maybeShrinkCapacity();\n\n        return true;\n    }\n\n    delete(key, noRehash) {\n        const i = this.indexOfKey(key);\n        if (i < 0) return false;\n\n        this.state[i] = FREE;\n        this.distinct--;\n\n        if (!noRehash) this.maybeShrinkCapacity();\n\n        return true;\n    }\n\n    maybeShrinkCapacity() {\n        if (this.distinct < this.lowWaterMark) {\n            const newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);\n            this.rehash(newCapacity);\n        }\n    }\n\n    containsKey(key) {\n        return this.indexOfKey(key) >= 0;\n    }\n\n    indexOfKey(key) {\n        const table = this.table;\n        const state = this.state;\n        const length = this.table.length;\n\n        const hash = key & 0x7fffffff;\n        let i = hash % length;\n        let decrement = hash % (length - 2);\n        if (decrement === 0) decrement = 1;\n\n        while (state[i] !== FREE && (state[i] === REMOVED || table[i] !== key)) {\n            i -= decrement;\n            if (i < 0) i += length;\n        }\n\n        if (state[i] === FREE) return -1;\n        return i;\n    }\n\n    containsValue(value) {\n        return this.indexOfValue(value) >= 0;\n    }\n\n    indexOfValue(value) {\n        const values = this.values;\n        const state = this.state;\n\n        for (var i = 0; i < state.length; i++) {\n            if (state[i] === FULL && values[i] === value) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    indexOfInsertion(key) {\n        const table = this.table;\n        const state = this.state;\n        const length = table.length;\n\n\n        const hash = key & 0x7fffffff;\n        let i = hash % length;\n        let decrement = hash % (length - 2);\n        if (decrement === 0) decrement = 1;\n\n        while (state[i] === FULL && table[i] !== key) {\n            i -= decrement;\n            if (i < 0) i += length;\n        }\n\n        if (state[i] === REMOVED) {\n            const j = i;\n            while (state[i] !== FREE && (state[i] === REMOVED || table[i] !== key)) {\n                i -= decrement;\n                if (i < 0) i += length;\n            }\n            if (state[i] === FREE) i = j;\n        }\n\n        if (state[i] === FULL) {\n            return -i - 1;\n        }\n\n        return i;\n    }\n\n    ensureCapacity(minCapacity) {\n        if (this.table.length < minCapacity) {\n            const newCapacity = nextPrime(minCapacity);\n            this.rehash(newCapacity);\n        }\n    }\n\n    rehash(newCapacity) {\n        const oldCapacity = this.table.length;\n\n        if (newCapacity <= this.distinct) throw new Error('Unexpected');\n\n        const oldTable = this.table;\n        const oldValues = this.values;\n        const oldState = this.state;\n\n        const newTable = newArray(newCapacity, 0);\n        const newValues = newArray(newCapacity, 0);\n        const newState = newArray(newCapacity, 0);\n\n        this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);\n        this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);\n\n        this.table = newTable;\n        this.values = newValues;\n        this.state = newState;\n        this.freeEntries = newCapacity - this.distinct;\n\n        for (var i = 0; i < oldCapacity; i++) {\n            if (oldState[i] === FULL) {\n                var element = oldTable[i];\n                var index = this.indexOfInsertion(element);\n                newTable[index] = element;\n                newValues[index] = oldValues[i];\n                newState[index] = FULL;\n            }\n        }\n    }\n\n    forEachKey(callback) {\n        for (var i = 0; i < this.state.length; i++) {\n            if (this.state[i] === FULL) {\n                if (!callback(this.table[i])) return false;\n            }\n        }\n        return true;\n    }\n\n    forEachValue(callback) {\n        for (var i = 0; i < this.state.length; i++) {\n            if (this.state[i] === FULL) {\n                if (!callback(this.values[i])) return false;\n            }\n        }\n        return true;\n    }\n\n    forEachPair(callback) {\n        for (var i = 0; i < this.state.length; i++) {\n            if (this.state[i] === FULL) {\n                if (!callback(this.table[i], this.values[i])) return false;\n            }\n        }\n        return true;\n    }\n}\n\nmodule.exports = HashTable;\n\nfunction chooseLowWaterMark(capacity, minLoad) {\n    return (capacity * minLoad) | 0;\n}\n\nfunction chooseHighWaterMark(capacity, maxLoad) {\n    return Math.min(capacity - 2, (capacity * maxLoad) | 0);\n}\n\nfunction chooseGrowCapacity(size, minLoad, maxLoad) {\n    return nextPrime(Math.max(size + 1, (4 * size / (3 * minLoad + maxLoad)) | 0));\n}\n\nfunction chooseShrinkCapacity(size, minLoad, maxLoad) {\n    return nextPrime(Math.max(size + 1, (4 * size / (minLoad + 3 * maxLoad)) | 0));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hash-table/src/HashTable.js\n// module id = 28\n// module chunks = 0","const binarySearch = require('binary-search');\nconst sortAsc = require('num-sort').asc;\n\nconst largestPrime = 0x7fffffff;\n\nconst primeNumbers = [\n    //chunk #0\n    largestPrime, // 2^31-1\n\n    //chunk #1\n    5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759,\n    411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939,\n    210719881, 421439783, 842879579, 1685759167,\n\n    //chunk #2\n    433, 877, 1759, 3527, 7057, 14143, 28289, 56591, 113189, 226379, 452759, 905551, 1811107,\n    3622219, 7244441, 14488931, 28977863, 57955739, 115911563, 231823147, 463646329, 927292699,\n    1854585413,\n\n    //chunk #3\n    953, 1907, 3821, 7643, 15287, 30577, 61169, 122347, 244703, 489407, 978821, 1957651, 3915341,\n    7830701, 15661423, 31322867, 62645741, 125291483, 250582987, 501165979, 1002331963,\n    2004663929,\n\n    //chunk #4\n    1039, 2081, 4177, 8363, 16729, 33461, 66923, 133853, 267713, 535481, 1070981, 2141977, 4283963,\n    8567929, 17135863, 34271747, 68543509, 137087021, 274174111, 548348231, 1096696463,\n\n    //chunk #5\n    31, 67, 137, 277, 557, 1117, 2237, 4481, 8963, 17929, 35863, 71741, 143483, 286973, 573953,\n    1147921, 2295859, 4591721, 9183457, 18366923, 36733847, 73467739, 146935499, 293871013,\n    587742049, 1175484103,\n\n    //chunk #6\n    599, 1201, 2411, 4831, 9677, 19373, 38747, 77509, 155027, 310081, 620171, 1240361, 2480729,\n    4961459, 9922933, 19845871, 39691759, 79383533, 158767069, 317534141, 635068283, 1270136683,\n\n    //chunk #7\n    311, 631, 1277, 2557, 5119, 10243, 20507, 41017, 82037, 164089, 328213, 656429, 1312867,\n    2625761, 5251529, 10503061, 21006137, 42012281, 84024581, 168049163, 336098327, 672196673,\n    1344393353,\n\n    //chunk #8\n    3, 7, 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,\n    701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,\n    359339171, 718678369, 1437356741,\n\n    //chunk #9\n    43, 89, 179, 359, 719, 1439, 2879, 5779, 11579, 23159, 46327, 92657, 185323, 370661, 741337,\n    1482707, 2965421, 5930887, 11861791, 23723597, 47447201, 94894427, 189788857, 379577741,\n    759155483, 1518310967,\n\n    //chunk #10\n    379, 761, 1523, 3049, 6101, 12203, 24407, 48817, 97649, 195311, 390647, 781301, 1562611,\n    3125257, 6250537, 12501169, 25002389, 50004791, 100009607, 200019221, 400038451, 800076929,\n    1600153859,\n\n    //chunk #11\n    13, 29, 59, 127, 257, 521, 1049, 2099, 4201, 8419, 16843, 33703, 67409, 134837, 269683,\n    539389, 1078787, 2157587, 4315183, 8630387, 17260781, 34521589, 69043189, 138086407,\n    276172823, 552345671, 1104691373,\n\n    //chunk #12\n    19, 41, 83, 167, 337, 677,\n    1361, 2729, 5471, 10949, 21911, 43853, 87719, 175447, 350899,\n    701819, 1403641, 2807303, 5614657, 11229331, 22458671, 44917381, 89834777, 179669557,\n    359339171, 718678369, 1437356741,\n\n    //chunk #13\n    53, 107, 223, 449, 907, 1823, 3659, 7321, 14653, 29311, 58631, 117269,\n    234539, 469099, 938207, 1876417, 3752839, 7505681, 15011389, 30022781,\n    60045577, 120091177, 240182359, 480364727, 960729461, 1921458943\n];\n\nprimeNumbers.sort(sortAsc);\n\nfunction nextPrime(value) {\n    let index = binarySearch(primeNumbers, value, sortAsc);\n    if (index < 0) {\n        index = ~index;\n    }\n    return primeNumbers[index];\n}\n\nexports.nextPrime = nextPrime;\nexports.largestPrime = largestPrime;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hash-table/src/primeFinder.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nconst euclidean = require('ml-distance-euclidean');\nconst ClusterLeaf = require('./ClusterLeaf');\nconst Cluster = require('./Cluster');\nconst distanceMatrix = require('ml-distance-matrix');\n\n/**\n * @private\n * @param cluster1\n * @param cluster2\n * @param disFun\n * @returns {number}\n */\nfunction simpleLink(cluster1, cluster2, disFun) {\n    var m = 10e100;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = 0; j < cluster2.length; j++) {\n            var d = disFun[cluster1[i]][ cluster2[j]];\n            m = Math.min(d, m);\n        }\n    }\n    return m;\n}\n\n/**\n * @private\n * @param cluster1\n * @param cluster2\n * @param disFun\n * @returns {number}\n */\nfunction completeLink(cluster1, cluster2, disFun) {\n    var m = -1;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = 0; j < cluster2.length; j++) {\n            var d = disFun[cluster1[i]][ cluster2[j]];\n            m = Math.max(d, m);\n        }\n    }\n    return m;\n}\n\n/**\n * @private\n * @param cluster1\n * @param cluster2\n * @param disFun\n * @returns {number}\n */\nfunction averageLink(cluster1, cluster2, disFun) {\n    var m = 0;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = 0; j < cluster2.length; j++) {\n            m += disFun[cluster1[i]][ cluster2[j]];\n        }\n    }\n    return m / (cluster1.length * cluster2.length);\n}\n\n/**\n * @private\n * @param cluster1\n * @param cluster2\n * @param disFun\n * @returns {*}\n */\nfunction centroidLink(cluster1, cluster2, disFun) {\n    var dist = new Array(cluster1.length * cluster2.length);\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = 0; j < cluster2.length; j++) {\n            dist[i * cluster2.length + j] = (disFun[cluster1[i]][ cluster2[j]]);\n        }\n    }\n    return median(dist);\n}\n\n/**\n * @private\n * @param cluster1\n * @param cluster2\n * @param disFun\n * @returns {number}\n */\nfunction wardLink(cluster1, cluster2, disFun) {\n    return centroidLink(cluster1, cluster2, disFun)\n        * cluster1.length * cluster2.length / (cluster1.length + cluster2.length);\n}\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\nfunction median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n}\n\nvar defaultOptions = {\n    disFunc: euclidean,\n    kind: 'single',\n    isDistanceMatrix: false\n\n};\n\n/**\n * Continuously merge nodes that have the least dissimilarity\n * @param {Array <Array <number>>} distance - Array of points to be clustered\n * @param {json} options\n * @option isDistanceMatrix: Is the input a distance matrix?\n * @constructor\n */\nfunction agnes(data, options) {\n    options = Object.assign({}, defaultOptions, options);\n    var len = data.length;\n    var distance = data;//If source\n    if (!options.isDistanceMatrix) {\n        distance = distanceMatrix(data, options.disFunc);\n    }\n\n\n    // allows to use a string or a given function\n    if (typeof options.kind === 'string') {\n        switch (options.kind) {\n            case 'single':\n                options.kind = simpleLink;\n                break;\n            case 'complete':\n                options.kind = completeLink;\n                break;\n            case 'average':\n                options.kind = averageLink;\n                break;\n            case 'centroid':\n                options.kind = centroidLink;\n                break;\n            case 'ward':\n                options.kind = wardLink;\n                break;\n            default:\n                throw new RangeError('Unknown kind of similarity');\n        }\n    } else if (typeof options.kind !== 'function') {\n        throw new TypeError('Undefined kind of similarity');\n    }\n\n    var list = new Array(len);\n    for (var i = 0; i < distance.length; i++) {\n        list[i] = new ClusterLeaf(i);\n    }\n    var min = 10e5,\n        d = {},\n        dis = 0;\n\n    while (list.length > 1) {\n        // calculates the minimum distance\n        d = {};\n        min = 10e5;\n        for (var j = 0; j < list.length; j++) {\n            for (var k = j + 1; k < list.length; k++) {\n                var fdistance, sdistance;\n                if (list[j] instanceof ClusterLeaf) {\n                    fdistance = [list[j].index];\n                } else {\n                    fdistance = new Array(list[j].index.length);\n                    for (var e = 0; e < fdistance.length; e++) {\n                        fdistance[e] = list[j].index[e].index;\n                    }\n                }\n                if (list[k] instanceof ClusterLeaf) {\n                    sdistance = [list[k].index];\n                } else {\n                    sdistance = new Array(list[k].index.length);\n                    for (var f = 0; f < sdistance.length; f++) {\n                        sdistance[f] = list[k].index[f].index;\n                    }\n                }\n                dis = options.kind(fdistance, sdistance, distance).toFixed(4);\n                if (dis in d) {\n                    d[dis].push([list[j], list[k]]);\n                } else {\n                    d[dis] = [[list[j], list[k]]];\n                }\n                min = Math.min(dis, min);\n            }\n        }\n        // cluster dots\n        var dmin = d[min.toFixed(4)];\n        var clustered = new Array(dmin.length);\n        var aux,\n            count = 0;\n        while (dmin.length > 0) {\n            aux = dmin.shift();\n            for (var q = 0; q < dmin.length; q++) {\n                var int = dmin[q].filter(function (n) {\n                    //noinspection JSReferencingMutableVariableFromClosure\n                    return aux.indexOf(n) !== -1;\n                });\n                if (int.length > 0) {\n                    var diff = dmin[q].filter(function (n) {\n                        //noinspection JSReferencingMutableVariableFromClosure\n                        return aux.indexOf(n) === -1;\n                    });\n                    aux = aux.concat(diff);\n                    dmin.splice(q--, 1);\n                }\n            }\n            clustered[count++] = aux;\n        }\n        clustered.length = count;\n\n        for (var ii = 0; ii < clustered.length; ii++) {\n            var obj = new Cluster();\n            obj.children = clustered[ii].concat();\n            obj.distance = min;\n            obj.index = new Array(len);\n            var indCount = 0;\n            for (var jj = 0; jj < clustered[ii].length; jj++) {\n                if (clustered[ii][jj] instanceof ClusterLeaf) {\n                    obj.index[indCount++] = clustered[ii][jj];\n                } else {\n                    indCount += clustered[ii][jj].index.length;\n                    obj.index = clustered[ii][jj].index.concat(obj.index);\n                }\n                list.splice((list.indexOf(clustered[ii][jj])), 1);\n            }\n            obj.index.length = indCount;\n            list.push(obj);\n        }\n    }\n    return list[0];\n}\n\nmodule.exports = agnes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hclust/src/agnes.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nconst euclidean = require('ml-distance-euclidean');\nconst ClusterLeaf = require('./ClusterLeaf');\nconst Cluster = require('./Cluster');\n\n/**\n * @private\n * @param {Array <Array <number>>} cluster1\n * @param {Array <Array <number>>} cluster2\n * @param {function} disFun\n * @returns {number}\n */\nfunction simpleLink(cluster1, cluster2, disFun) {\n    var m = 10e100;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = i; j < cluster2.length; j++) {\n            var d = disFun(cluster1[i], cluster2[j]);\n            m = Math.min(d, m);\n        }\n    }\n    return m;\n}\n\n/**\n * @private\n * @param {Array <Array <number>>} cluster1\n * @param {Array <Array <number>>} cluster2\n * @param {function} disFun\n * @returns {number}\n */\nfunction completeLink(cluster1, cluster2, disFun) {\n    var m = -1;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = i; j < cluster2.length; j++) {\n            var d = disFun(cluster1[i], cluster2[j]);\n            m = Math.max(d, m);\n        }\n    }\n    return m;\n}\n\n/**\n * @private\n * @param {Array <Array <number>>} cluster1\n * @param {Array <Array <number>>} cluster2\n * @param {function} disFun\n * @returns {number}\n */\nfunction averageLink(cluster1, cluster2, disFun) {\n    var m = 0;\n    for (var i = 0; i < cluster1.length; i++) {\n        for (var j = 0; j < cluster2.length; j++) {\n            m += disFun(cluster1[i], cluster2[j]);\n        }\n    }\n    return m / (cluster1.length * cluster2.length);\n}\n\n/**\n * @private\n * @param {Array <Array <number>>} cluster1\n * @param {Array <Array <number>>} cluster2\n * @param {function} disFun\n * @returns {number}\n */\nfunction centroidLink(cluster1, cluster2, disFun) {\n    var x1 = 0,\n        y1 = 0,\n        x2 = 0,\n        y2 = 0;\n    for (var i = 0; i < cluster1.length; i++) {\n        x1 += cluster1[i][0];\n        y1 += cluster1[i][1];\n    }\n    for (var j = 0; j < cluster2.length; j++) {\n        x2 += cluster2[j][0];\n        y2 += cluster2[j][1];\n    }\n    x1 /= cluster1.length;\n    y1 /= cluster1.length;\n    x2 /= cluster2.length;\n    y2 /= cluster2.length;\n    return disFun([x1, y1], [x2, y2]);\n}\n\n/**\n * @private\n * @param {Array <Array <number>>} cluster1\n * @param {Array <Array <number>>} cluster2\n * @param {function} disFun\n * @returns {number}\n */\nfunction wardLink(cluster1, cluster2, disFun) {\n    var x1 = 0,\n        y1 = 0,\n        x2 = 0,\n        y2 = 0;\n    for (var i = 0; i < cluster1.length; i++) {\n        x1 += cluster1[i][0];\n        y1 += cluster1[i][1];\n    }\n    for (var j = 0; j < cluster2.length; j++) {\n        x2 += cluster2[j][0];\n        y2 += cluster2[j][1];\n    }\n    x1 /= cluster1.length;\n    y1 /= cluster1.length;\n    x2 /= cluster2.length;\n    y2 /= cluster2.length;\n    return disFun([x1, y1], [x2, y2]) * cluster1.length * cluster2.length / (cluster1.length + cluster2.length);\n}\n\n/**\n * @private\n * Returns the most distant point and his distance\n * @param {Array <Array <number>>} splitting - Clusters to split\n * @param {Array <Array <number>>} data - Original data\n * @param {function} disFun - Distance function\n * @returns {{d: number, p: number}} - d: maximum difference between points, p: the point more distant\n */\nfunction diff(splitting, data, disFun) {\n    var ans = {\n        d: 0,\n        p: 0\n    };\n\n    var Ci = new Array(splitting[0].length);\n    for (var e = 0; e < splitting[0].length; e++) {\n        Ci[e] = data[splitting[0][e]];\n    }\n    var Cj = new Array(splitting[1].length);\n    for (var f = 0; f < splitting[1].length; f++) {\n        Cj[f] = data[splitting[1][f]];\n    }\n\n    var dist, ndist;\n    for (var i = 0; i < Ci.length; i++) {\n        dist = 0;\n        for (var j = 0; j < Ci.length; j++) {\n            if (i !== j) {\n                dist += disFun(Ci[i], Ci[j]);\n            }\n        }\n        dist /= (Ci.length - 1);\n        ndist = 0;\n        for (var k = 0; k < Cj.length; k++) {\n            ndist += disFun(Ci[i], Cj[k]);\n        }\n        ndist /= Cj.length;\n        if ((dist - ndist) > ans.d) {\n            ans.d = (dist - ndist);\n            ans.p = i;\n        }\n    }\n    return ans;\n}\n\nvar defaultOptions = {\n    dist: euclidean,\n    kind: 'single'\n};\n\n/**\n * @private\n * Intra-cluster distance\n * @param {Array} index\n * @param {Array} data\n * @param {function} disFun\n * @returns {number}\n */\nfunction intrDist(index, data, disFun) {\n    var dist = 0,\n        count = 0;\n    for (var i = 0; i < index.length; i++) {\n        for (var j = i; j < index.length; j++) {\n            dist += disFun(data[index[i].index], data[index[j].index]);\n            count++;\n        }\n    }\n    return dist / count;\n}\n\n/**\n * Splits the higher level clusters\n * @param {Array <Array <number>>} data - Array of points to be clustered\n * @param {json} options\n * @constructor\n */\nfunction diana(data, options) {\n    options = Object.assign({}, defaultOptions, options);\n    if (typeof options.kind === 'string') {\n        switch (options.kind) {\n            case 'single':\n                options.kind = simpleLink;\n                break;\n            case 'complete':\n                options.kind = completeLink;\n                break;\n            case 'average':\n                options.kind = averageLink;\n                break;\n            case 'centroid':\n                options.kind = centroidLink;\n                break;\n            case 'ward':\n                options.kind = wardLink;\n                break;\n            default:\n                throw new RangeError('Unknown kind of similarity');\n        }\n    } else if (typeof options.kind !== 'function') {\n        throw new TypeError('Undefined kind of similarity');\n    }\n    var tree = new Cluster();\n    tree.children = new Array(data.length);\n    tree.index = new Array(data.length);\n    for (var ind = 0; ind < data.length; ind++) {\n        tree.children[ind] = new ClusterLeaf(ind);\n        tree.index[ind] = new ClusterLeaf(ind);\n    }\n\n    tree.distance = intrDist(tree.index, data, options.dist);\n    var m, M, clId,\n        dist, rebel;\n    var list = [tree];\n    while (list.length > 0) {\n        M = 0;\n        clId = 0;\n        for (var i = 0; i < list.length; i++) {\n            m = 0;\n            for (var j = 0; j < list[i].length; j++) {\n                for (var l = (j + 1); l < list[i].length; l++) {\n                    m = Math.max(options.dist(data[list[i].index[j].index], data[list[i].index[l].index]), m);\n                }\n            }\n            if (m > M) {\n                M = m;\n                clId = i;\n            }\n        }\n        M = 0;\n        if (list[clId].index.length === 2) {\n            list[clId].children = [list[clId].index[0], list[clId].index[1]];\n            list[clId].distance = options.dist(data[list[clId].index[0].index], data[list[clId].index[1].index]);\n        } else if (list[clId].index.length === 3) {\n            list[clId].children = [list[clId].index[0], list[clId].index[1], list[clId].index[2]];\n            var d = [\n                options.dist(data[list[clId].index[0].index], data[list[clId].index[1].index]),\n                options.dist(data[list[clId].index[1].index], data[list[clId].index[2].index])\n            ];\n            list[clId].distance = (d[0] + d[1]) / 2;\n        } else {\n            var C = new Cluster();\n            var sG = new Cluster();\n            var splitting = [new Array(list[clId].index.length), []];\n            for (var spl = 0; spl < splitting[0].length; spl++) {\n                splitting[0][spl] = spl;\n            }\n            for (var ii = 0; ii < splitting[0].length; ii++) {\n                dist = 0;\n                for (var jj = 0; jj < splitting[0].length; jj++) {\n                    if (ii !== jj) {\n                        dist += options.dist(data[list[clId].index[splitting[0][jj]].index], data[list[clId].index[splitting[0][ii]].index]);\n                    }\n                }\n                dist /= (splitting[0].length - 1);\n                if (dist > M) {\n                    M = dist;\n                    rebel = ii;\n                }\n            }\n            splitting[1] = [rebel];\n            splitting[0].splice(rebel, 1);\n            dist = diff(splitting, data, options.dist);\n            while (dist.d > 0) {\n                splitting[1].push(splitting[0][dist.p]);\n                splitting[0].splice(dist.p, 1);\n                dist = diff(splitting, data, options.dist);\n            }\n            var fData = new Array(splitting[0].length);\n            C.index = new Array(splitting[0].length);\n            for (var e = 0; e < fData.length; e++) {\n                fData[e] = data[list[clId].index[splitting[0][e]].index];\n                C.index[e] = list[clId].index[splitting[0][e]];\n                C.children[e] = list[clId].index[splitting[0][e]];\n            }\n            var sData = new Array(splitting[1].length);\n            sG.index = new Array(splitting[1].length);\n            for (var f = 0; f < sData.length; f++) {\n                sData[f] = data[list[clId].index[splitting[1][f]].index];\n                sG.index[f] = list[clId].index[splitting[1][f]];\n                sG.children[f] = list[clId].index[splitting[1][f]];\n            }\n            C.distance = intrDist(C.index, data, options.dist);\n            sG.distance = intrDist(sG.index, data, options.dist);\n            list.push(C);\n            list.push(sG);\n            list[clId].children = [C, sG];\n        }\n        list.splice(clId, 1);\n    }\n    return tree;\n}\n\nmodule.exports = diana;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hclust/src/diana.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nexports.agnes = require('./agnes');\nexports.diana = require('./diana');\n//exports.birch = require('./birch');\n//exports.cure = require('./cure');\n//exports.chameleon = require('./chameleon');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-hclust/src/index.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric()) {\n        throw new Error('Matrix is not symmetric');\n    }\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get lowerTriangularMatrix() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/cholesky.js\n// module id = 33\n// module chunks = 0","'use strict';\n\nconst Matrix = require('../matrix').Matrix;\nconst util = require('./util');\nconst hypotenuse = util.hypotenuse;\nconst getFilled2DArray = util.getFilled2DArray;\n\nconst defaultOptions = {\n    assumeSymmetric: false\n};\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix, options) {\n    options = Object.assign({}, defaultOptions, options);\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix, options);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = getFilled2DArray(n, n, 0),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    var isSymmetric = false;\n    if (options.assumeSymmetric) {\n        isSymmetric = true;\n    } else {\n        isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value.get(i, j);\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    } else {\n        var H = getFilled2DArray(n, n, 0),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value.get(i, j);\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        if (!Matrix.isMatrix(this.V)) {\n            this.V = new Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            } else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    } else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/evd.js\n// module id = 34\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m) {\n            throw new Error('Matrix row dimensions must agree');\n        }\n        if (!this.isFullRank()) {\n            throw new Error('Matrix is rank deficient');\n        }\n\n        var count = value.columns;\n        var X = value.clone();\n        var n = qr.columns;\n        var i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularMatrix() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalMatrix() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/qr.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nvar Matrix = require('./matrix').Matrix;\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.inverse = Matrix.inv = inverse;\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.prototype.inverse = Matrix.prototype.inv = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    leftHandSide = Matrix.checkMatrix(leftHandSide);\n    rightHandSide = Matrix.checkMatrix(rightHandSide);\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.solve = solve;\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/decompositions.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nif (!Symbol.species) {\n    Symbol.species = Symbol.for('@@species');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/symbol-species.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixColumnView extends BaseView {\n    constructor(matrix, column) {\n        super(matrix, matrix.rows, 1);\n        this.column = column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.column, value);\n        return this;\n    }\n\n    get(rowIndex) {\n        return this.matrix.get(rowIndex, this.column);\n    }\n}\n\nmodule.exports = MatrixColumnView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/column.js\n// module id = 38\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipColumnView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n    }\n}\n\nmodule.exports = MatrixFlipColumnView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/flipColumn.js\n// module id = 39\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipRowView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n    }\n}\n\nmodule.exports = MatrixFlipRowView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/flipRow.js\n// module id = 40\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixRowView extends BaseView {\n    constructor(matrix, row) {\n        super(matrix, 1, matrix.columns);\n        this.row = row;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.row, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.row, columnIndex);\n    }\n}\n\nmodule.exports = MatrixRowView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/row.js\n// module id = 41\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSelectionView extends BaseView {\n    constructor(matrix, rowIndices, columnIndices) {\n        var indices = util.checkIndices(matrix, rowIndices, columnIndices);\n        super(matrix, indices.row.length, indices.column.length);\n        this.rowIndices = indices.row;\n        this.columnIndices = indices.column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);\n    }\n}\n\nmodule.exports = MatrixSelectionView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/selection.js\n// module id = 42\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSubView extends BaseView {\n    constructor(matrix, startRow, endRow, startColumn, endColumn) {\n        util.checkRange(matrix, startRow, endRow, startColumn, endColumn);\n        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n        this.startRow = startRow;\n        this.startColumn = startColumn;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);\n    }\n}\n\nmodule.exports = MatrixSubView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/sub.js\n// module id = 43\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixTransposeView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.columns, matrix.rows);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(columnIndex, rowIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(columnIndex, rowIndex);\n    }\n}\n\nmodule.exports = MatrixTransposeView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/transpose.js\n// module id = 44\n// module chunks = 0","/**\n * Created by acastillo on 8/8/16.\n */\n'use strict';\n\nconst defOptions = {\n    threshold:0,\n    out:\"assignment\"\n};\n//TODO Consider a matrix of distances too\nmodule.exports = function fullClusterGenerator(conMat, opt) {\n    const options = Object.assign({}, defOptions, opt);\n    var clList, i, j, k;\n    if(typeof conMat[0] === \"number\"){\n        clList = fullClusterGeneratorVector(conMat);\n    }\n    else{\n        if(typeof conMat[0] === \"object\"){\n            var nRows = conMat.length;\n            var conn = new Array(nRows*(nRows+1)/2);\n            var index = 0;\n            for(var i=0;i<nRows;i++){\n                for(var j=i;j<nRows;j++){\n                    if(conMat[i][j]>options.threshold)\n                        conn[index++]= 1;\n                    else\n                        conn[index++]= 0;\n                }\n            }\n            clList = fullClusterGeneratorVector(conn);\n        }\n    }\n    if (options.out === \"indexes\" || options.out === \"values\") {\n        var result = new Array(clList.length);\n        for(i=0;i<clList.length;i++){\n            result[i] = [];\n            for(j=0;j<clList[i].length;j++){\n                if(clList[i][j] != 0){\n                    result[i].push(j);\n                }\n            }\n        }\n        if (options.out === \"values\") {\n            var resultAsMatrix = new Array(result.length);\n            for (i = 0; i<result.length;i++){\n                resultAsMatrix[i]=new Array(result[i].length);\n                for(j = 0; j < result[i].length; j++){\n                    resultAsMatrix[i][j]=new Array(result[i].length);\n                    for(k = 0; k < result[i].length; k++){\n                        resultAsMatrix[i][j][k]=conMat[result[i][j]][result[i][k]];\n                    }\n                }\n            }\n            return resultAsMatrix;\n        }\n        else{\n            return result;\n        }\n    }\n\n    return clList;\n\n}\n\nfunction fullClusterGeneratorVector(conn){\n    var nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n    var clusterList = [];\n    var available = new Array(nRows);\n    var remaining = nRows, i=0;\n    var cluster = [];\n    //Mark all the elements as available\n    for(i=nRows-1;i>=0;i--){\n        available[i]=1;\n    }\n    var nextAv=-1;\n    var toInclude = [];\n    while(remaining>0){\n        if(toInclude.length===0){\n            //If there is no more elements to include. Start a new cluster\n            cluster = new Array(nRows);\n            for(i = 0;i < nRows ;i++)\n                cluster[i]=0;\n            clusterList.push(cluster);\n            for(nextAv = 0;available[nextAv]==0;nextAv++){};\n        }\n        else{\n            nextAv=toInclude.splice(0,1);\n        }\n        cluster[nextAv]=1;\n        available[nextAv]=0;\n        remaining--;\n        //Copy the next available row\n        var row = new Array(nRows);\n        for( i = 0;i < nRows;i++){\n            var c=Math.max(nextAv,i);\n            var r=Math.min(nextAv,i);\n            //The element in the conn matrix\n            //console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n            row[i]=conn[r*(2*nRows-r-1)/2+c];\n            //There is new elements to include in this row?\n            //Then, include it to the current cluster\n            if(row[i]==1&&available[i]==1&&cluster[i]==0){\n                toInclude.push(i);\n                cluster[i]=1;\n            }\n        }\n    }\n    return clusterList;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-simple-clustering/src/index.js\n// module id = 45\n// module chunks = 0","'use strict';\n\nvar arrayStat = require('./array');\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\nexports.max = function max(matrix) {\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return max;\n};\n\nexports.min = function min(matrix) {\n    var min = Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n        }\n    }\n    return min;\n};\n\nexports.minMax = function minMax(matrix) {\n    var min = Infinity;\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return {\n        min:min,\n        max:max\n    };\n};\n\nexports.entropy = function entropy(matrix, eps) {\n    if (typeof (eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n};\n\nexports.mean = function mean(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n};\n\nexports.sum = function sum(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theSum, i, j;\n\n    if (dimension === -1) {\n        theSum = [0];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theSum[0] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theSum = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theSum[j] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theSum = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theSum[j] += matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theSum;\n};\n\nexports.product = function product(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theProduct, i, j;\n\n    if (dimension === -1) {\n        theProduct = [1];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theProduct[0] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theProduct = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < rows; i++) {\n                theProduct[j] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theProduct = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < cols; i++) {\n                theProduct[j] *= matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theProduct;\n};\n\nexports.standardDeviation = function standardDeviation(matrix, means, unbiased) {\n    var vari = exports.variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n};\n\nexports.variance = function variance(matrix, means, unbiased) {\n    if (typeof (unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n};\n\nexports.median = function median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort(compareNumbers);\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n};\n\nexports.mode = function mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n};\n\nexports.skewness = function skewness(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n};\n\nexports.kurtosis = function kurtosis(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n};\n\nexports.standardError = function standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = exports.standardDeviation(matrix);\n    var l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n};\n\nexports.covariance = function covariance(matrix, dimension) {\n    return exports.scatter(matrix, undefined, dimension);\n};\n\nexports.scatter = function scatter(matrix, divisor, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof (divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = exports.mean(matrix, dimension);\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n\nexports.correlation = function correlation(matrix) {\n    var means = exports.mean(matrix),\n        standardDeviations = exports.standardDeviation(matrix, true, means),\n        scores = exports.zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n};\n\nexports.zScores = function zScores(matrix, means, standardDeviations) {\n    means = means || exports.mean(matrix);\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix, true, means);\n    return exports.standardize(exports.center(matrix, means, false), standardDeviations, true);\n};\n\nexports.center = function center(matrix, means, inPlace) {\n    means = means || exports.mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n};\n\nexports.standardize = function standardize(matrix, standardDeviations, inPlace) {\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n};\n\nexports.weightedVariance = function weightedVariance(matrix, weights) {\n    var means = exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n};\n\nexports.weightedMean = function weightedMean(matrix, weights, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n};\n\nexports.weightedCovariance = function weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return exports.weightedScatter(matrix, weights, means, factor, dimension);\n};\n\nexports.weightedScatter = function weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    if (typeof (factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/matrix.js\n// module id = 46\n// module chunks = 0","'use strict';\nmodule.exports = Number.isNaN || function (x) {\n\treturn x !== x;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/number-is-nan/index.js\n// module id = 47\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 48\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/~/inherits/inherits_browser.js\n// module id = 49\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/support/isBufferBrowser.js\n// module id = 50\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/util.js\n// module id = 51\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 52\n// module chunks = 0","'use strict';\n\nexports.SpinSystem = require('./SpinSystem');\nexports.simulate1D = require('./simulate1D');\nexports.simulate2D = require('./simulate2D');\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}